// Package {{ .PackageName }} - DO NOT EDIT THIS FILE: Auto-generated code by https://github.com/foomo/gocontentful
{{ $cfg := . }}{{ $contentTypes := .ContentTypes }}{{ $locales := .Locales }}package {{ .PackageName }}

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"regexp"
	"strings"
	"time"
	"github.com/foomo/contentful"
	"golang.org/x/sync/errgroup"
)

type cacheEntryMaps struct {
	{{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }} map[string]*Cf{{ firstCap $contentType.Sys.ID }}
	{{ end }}
}

type ClientMode string

type ContentfulCache struct {
	assets           assetCacheMap
	contentTypes     []string
	entryMaps        cacheEntryMaps
	idContentTypeMap map[string]string
	parentMap        map[string][]EntryReference // Maps each entry ID to its parents' IDs
}

type assetCacheMap map[string]*contentful.Asset

type ContentfulClient struct {
	Cache  *ContentfulCache
	clientMode ClientMode
	Client     *contentful.Contentful
	locales    []Locale
	logFn      func(
			fields map[string]interface{},
			level int,
			args ...interface{},
	)
	logLevel           int
	optimisticPageSize uint16 // Start downloading entries at this page size
	SpaceID            string
}

type ContentTypeResult struct {
	EntryID     string
	ContentType string
	References  map[string][]EntryReference
}

type EntryReference struct {
	ContentType string
	ID string
	VO interface{}
}

type ImageResolverFunc func(assetID string, locale Locale) (attrs map[string]string, resolveError error)
type EntryLinkResolverFunc func(entryID string, locale Locale) (resolvedAttrs map[string]string, resolveError error)
type LinkResolverFunc func(url string) (resolvedAttrs map[string]string, resolveError error)

type Locale string

const (
	ClientModeCDA ClientMode = "CDA"
	ClientModeCPA ClientMode = "CPA"
	ClientModeCMA ClientMode = "CMA"
)

const (
	LogDebug = 0
	LogInfo = 1
	LogWarn = 2
	LogError = 3
)

{{ range $index , $locale := $locales }}const SpaceLocale{{ onlyLetters $locale.Name }} Locale = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale Locale = SpaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var localeFallback = map[Locale]Locale{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} SpaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}SpaceLocale{{ onlyLetters $localeSearch.Name }}{{ end }}{{ end }}, {{ else }}SpaceLocale{{ onlyLetters $locale.Name }}: "", {{ end }}{{ end }}}

const (
	assetPageSize = 1000
	assetWorkerType = "_asset"
)

const cacheUpdateConcurrency = 4

const (
	sysTypeEntry = "Entry"
	sysTypeAsset = "Asset"
)

var (
	ErrLocaleUnsupported   = errors.New("locale not supported by this space")
	ErrNotSet              = errors.New("field value not set")
	ErrNotSetNoFallback    = errors.New("field value not set and no fallback locale available")
	ErrRefNotIncludes      = errors.New("referenced entry not found in includes")
	ErrNoTypeOfRefEntry    = errors.New("couldn't get contentType of referenced entry")
	ErrNoTypeOfRefAsset    = errors.New("couldn't get contentType of referenced asset")
	InfoUpdatedEntityCache = "updated cache for entity"
	InfoCachedAllEntries   = "cached all entries of content type"
	InfoCachedAllAssets    = "cached all assets"
	InfoUpdateCacheTime    = "space caching done, time recorded"
)

var spaceContentTypes = []string{ {{ range $index , $contentType := $contentTypes }}ContentType{{ firstCap $contentType.Sys.ID }}, {{ end }} }

func (cc *ContentfulClient) CacheHasContentType(contentTypeID string) bool {
	for _, cachedContentType := range cc.Cache.contentTypes {
		if cachedContentType == contentTypeID {
			return true
		}
	}
	return false
}

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}

func (cc *ContentfulClient) DeleteAsset(asset *contentful.Asset) error {
	if cc.Client == nil {
		return errors.New("DeleteAsset: No client available")
	}
	if cc.clientMode != ClientModeCMA {
		return errors.New("DeleteAsset: Only available in ClientModeCMA")
	}
	errUnpublish := cc.Client.Assets.Unpublish(cc.SpaceID, asset)
	if errUnpublish != nil && !strings.Contains(errUnpublish.Error(), "Not published") {
		return errUnpublish
	}
	errDelete := cc.Client.Assets.Delete(cc.SpaceID, asset)
	if errDelete != nil {
		return errDelete
	}
	return nil
}

func (cc *ContentfulClient) DeleteAssetFromCache(key string) error {
	return cc.deleteAssetFromCache(key)
}

func (cc *ContentfulClient) GetAllAssets() (map[string]*contentful.Asset, error) {
	return cc.getAllAssets(true)
}

func (cc *ContentfulClient) GetAssetByID(id string) (*contentful.Asset, error) {
	if cc.Client == nil {
		return nil, errors.New("GetAssetByID: No client available")
	}
	if cc.Cache != nil && cc.Cache.assets != nil {
		asset, okAsset := cc.Cache.assets[id]
		if okAsset {
			return asset, nil
		}
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Equal("sys.id",id)
	_, err := col.Next()
	if err != nil {
		return nil, err
	}
	if len(col.Items) == 0 {
		return nil, errors.New("GetAssetByID: Not found "+ id)
	}
	item := col.Items[0]
	asset := contentful.Asset{}
	byt, err := json.Marshal(item)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(byt, &asset)
	if err != nil {
		return nil, err
	}
	for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
		if _, ok := asset.Fields.File[string(loc)]; ok {
			asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
		}
	}
	return &asset, nil
}

func (cc *ContentfulClient) GetContentTypeOfID(id string) (string, error) {
	if cc.Client == nil {
		return "", errors.New("GetContentTypeOfID: No client available")
	}
	if cc.Cache != nil {
		okVo := false
		{{ range $index , $contentType := $contentTypes }}
		_, okVo = cc.Cache.entryMaps.{{ $contentType.Sys.ID }}[id]
		if okVo {
			return ContentType{{ firstCap $contentType.Sys.ID }}, nil
		}
		{{ end }}
	}
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.Include(0).Equal("sys.id",id)
	_, err := col.GetAll()
	if err != nil {
		return "", errors.New("GetContentTypeOfID: "+err.Error())
	}
	if len(col.Items) == 0 {
		return "", fmt.Errorf("GetContentTypeOfID: %s Not found", id)
	}
	var vo genericEntryNoFields
	byteArray, _ := json.Marshal(col.Items[0])
	err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
	if err != nil {
		return "", errors.New("GetContentTypeOfID: "+err.Error())
	}
	return vo.Sys.ContentType.Sys.ID, nil
}

func HtmlToRichText(htmlSrc string) *RichTextNode {
	htmlClean := strings.TrimSpace(htmlSrc)
	htmlClean = strings.ReplaceAll(htmlClean, `&nbsp;`, ` `)
	htmlClean = strings.ReplaceAll(htmlClean, "\t", "")
	htmlClean = regexp.MustCompile(`[\s]{2,}`).ReplaceAllString(htmlClean, " ")
	re := regexp.MustCompile(`>([^\n])`)
	htmlClean = re.ReplaceAllString(htmlClean, fmt.Sprintf(">\n"+`$1`))
	re = regexp.MustCompile(`(.{1})<`)
	htmlClean = re.ReplaceAllString(htmlClean, `$1`+fmt.Sprintf("\n<"))
	htmlLines := strings.Split(htmlClean, "\n")
	rtnd := &RichTextNode{
		NodeType: RichTextNodeDocument,
	}
	var isBasic bool
	rtnd.Content, _, isBasic = richTextHtmlLinesToNode(htmlLines, 0, "", nil, true)
	if isBasic {
		basicRich := &RichTextNode{
			NodeType: RichTextNodeDocument,
		}
		par := RichTextNode{
			NodeType: RichTextNodeParagraph,
		}
		par.Content = rtnd.Content
		basicRich.Content = append(basicRich.Content, par)
		return basicRich
	}
	return rtnd
}

func NewAssetFromURL(id string, uploadUrl string, imageFileType string, title string, locale ...Locale) *contentful.Asset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc Locale
	if len(locale) != 0 {
		loc = locale[0]
		if localeFallback[loc]!="" {
			return nil
		}
	} else {
		loc = defaultLocale
	}
	asset := &contentful.Asset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				string(loc): {
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				string(loc): title,
			},
		},
	}
	return asset
}

func NewContentfulClient(spaceID string, clientMode ClientMode, clientKey string, optimisticPageSize uint16, logFn func(fields map[string]interface{}, level int, args ...interface{}), logLevel int, debug bool) (*ContentfulClient, error) {
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	if clientKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide an API key")
	}
	apiClient, err := getContentfulAPIClient(clientMode, clientKey)
	if err != nil {
		return nil, err
	}
	apiClient.Debug = debug
	cc := &ContentfulClient{
		clientMode:         clientMode,
		Client:             apiClient,
		locales:			[]Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }}, {{ end }} },
		logFn:              logFn,
		logLevel:           logLevel,
		optimisticPageSize: optimisticPageSize,
		SpaceID:            spaceID,
	}
	_, err = cc.Client.Spaces.Get(spaceID)
	if err != nil {
		_, ok := err.(contentful.NotFoundError)
		if ok {
			return nil, errors.New("NewContentfulClient: That is not the space you're looking for")
		}
		return nil, errors.New("NewContentfulClient: "+err.Error())
	}
	return cc, nil
}

func RichTextToHtml(rt interface{}, linkResolver LinkResolverFunc, entryLinkResolver EntryLinkResolverFunc, imageResolver ImageResolverFunc, locale Locale) (string, error) {
	w := bytes.NewBuffer([]byte{})
	node := &RichTextGenericNode{}
	byt, err := json.Marshal(rt)
	if err != nil {
		return "", err
	}
	err = json.Unmarshal(byt, node)
	if err != nil {
		return "", err
	}
	err = node.richTextRenderHTML(w, linkResolver, entryLinkResolver, imageResolver, locale)
	if err != nil {
		return "", err
	}
	out := string(w.Bytes())
	if out == "<p></p>" {
		return "", nil
	}
	return out, nil
}

func (cc *ContentfulClient) UpdateCache(ctx context.Context, contentTypes []string, cacheAssets bool) error {
	start := time.Now()
	tempCache := &ContentfulCache{
		contentTypes:     contentTypes,
		idContentTypeMap: map[string]string{},
		parentMap:        map[string][]EntryReference{},
	}
	for _, contentType := range contentTypes {
		if !stringSliceContains(spaceContentTypes, contentType) {
			return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
		}
	}
	if cacheAssets {
		contentTypes = append([]string{assetWorkerType}, contentTypes...)
	}
	results := make(chan ContentTypeResult, 16)
	resultsDone := make(chan struct{})
	contentTypeChan := make(chan string)
	group, gctx := errgroup.WithContext(ctx)
	for i := 0; i < cacheUpdateConcurrency; i++ {
		group.Go(func() error {
			for contentType := range contentTypeChan {
				err := updateCacheForContentType(gctx, results, cc, tempCache, contentType)
				if err != nil {
					return err
				}
			}
			return nil
		})
	}
	go func() {
		for _, contentType := range contentTypes {
			contentTypeChan <- contentType
		}
		close(contentTypeChan)
	}()
	go func() {
		for res := range results {
			tempCache.idContentTypeMap[res.EntryID] = res.ContentType
			for childID, references := range res.References {
				tempCache.parentMap[childID] = append(tempCache.parentMap[childID], references...)
			}
		}
		resultsDone <- struct{}{}
	}()
	err := group.Wait()
	close(results)
	if err != nil {
		// drain contentTypeChan
		for _ = range contentTypeChan {	}
		return err
	}
	// Signal that the cache build is done
	<-resultsDone

	if cc.logFn != nil && cc.logLevel <= LogInfo {
		cc.logFn(map[string]interface{}{"time elapsed":fmt.Sprint(time.Since(start)), "method": "UpdateCache"}, LogInfo, InfoUpdateCacheTime)
	}
	cc.Cache = tempCache
	return nil
}

func ToAssetReference(asset *contentful.Asset) (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeAsset
	return
}

func (cc *ContentfulClient) UpdateCacheForEntity(ctx context.Context, sysType string, contentType string, entityID string) error {
	if sysType == sysTypeEntry && cc.entryMapForContentTypeIsNil(contentType) {
		return fmt.Errorf("UpdateCacheForEntity: Content Type %q not available in cache", contentType)
	}
	if sysType == sysTypeAsset {
		contentType = assetWorkerType
	}
	if !stringSliceContains(spaceContentTypes, contentType) {
		return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
	}
	err := updateCacheForContentTypeAndEntity(ctx, cc, sysType, contentType, entityID)
	if err != nil {
		return err
	}
	return nil
}

func FieldToObject(jsonField interface{}, targetObject interface{}) error {
	byteArray, err := json.Marshal(jsonField)
	if err != nil {
		return err
	}
	err = json.Unmarshal(byteArray, &targetObject)
	if err != nil {
		return err
	}
	return nil
}

func (cc *ContentfulClient) deleteAssetFromCache(key string) error {
	if _, ok := cc.Cache.assets[key]; ok {
		delete(cc.Cache.assets, key)
		return nil
	}
	return errors.New("asset not found in cache, could not delete")
}

func (cc *ContentfulClient) entryMapForContentTypeIsNil(contentType string) bool {
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		if cc.Cache.entryMaps.{{ $contentType.Sys.ID }} == nil {
		return true
	}
	{{ end }}
	}
	return false
}

func getContentfulAPIClient(clientMode ClientMode, clientKey string) (*contentful.Contentful, error) {
	switch clientMode {
	case ClientModeCDA:
		return contentful.NewCDA(clientKey), nil
	case ClientModeCPA:
		return contentful.NewCPA(clientKey), nil
	case ClientModeCMA:
		return contentful.NewCMA(clientKey), nil
	default:
		return nil, errors.New("NewContentfulClient: Unknown ClientMode")
	}
}

func (cc *ContentfulClient) getAllAssets(tryCacheFirst bool) (map[string]*contentful.Asset, error) {
	if cc.Client == nil {
		return nil, errors.New("getAllAssets: No client available")
	}
	if cc.Cache != nil && cc.Cache.assets != nil && tryCacheFirst {
		return cc.Cache.assets, nil
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Limit(assetPageSize)
	assets := map[string]*contentful.Asset{}
	allItems := []interface{}{}
	for {
		_, err := col.Next()
		if err != nil {
			return nil, err
		}
		allItems = append(allItems, col.Items...)
		if uint16(len(col.Items)) < assetPageSize {
			break
		}
	}
	for _, item := range allItems {
		asset := contentful.Asset{}
		byt, err := json.Marshal(item)
		if err != nil {
			return nil, err
		}
		err = json.Unmarshal(byt, &asset)
		if err != nil {
			return nil, err
		}
		for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
			if _, ok := asset.Fields.File[string(loc)]; ok {
				asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
			}
		}
		assets[asset.Sys.ID] = &asset
	}
	return assets, nil
}

func (cc *ContentfulClient) optimisticPageSizeGetAll(contentType string, limit uint16) (*contentful.Collection, error) {
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.ContentType(contentType).Locale("*").Include(0).Limit(limit)
	allItems := []interface{}{}
	var err error
	for {
		_, err = col.Next()
		if err != nil {
			break
		}
		allItems = append(allItems, col.Items...)
		if uint16(len(col.Items)) < limit {
			break
		}
	}
	col.Items = allItems
	switch err.(type) {
	case contentful.ErrorResponse:
		msg := err.(contentful.ErrorResponse).Message
		if strings.Contains(msg, "Response size too big") && limit >= 20 {
			smallerPageCol, err := cc.optimisticPageSizeGetAll(contentType, limit/2)
			return smallerPageCol, err
		}
		return nil, err
	case nil:
	default:
		return nil, err
	}
	return col, nil
}

func richTextGetAttribute(htmlLine string, attribute string) string {
	re := regexp.MustCompile(` href=["']([^"']+)["']`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func richTextGetMark(mark string) string {
	switch mark {
	case HtmlItalic, HtmlEm:
		return RichTextMarkItalic
	case HtmlBold, HtmlStrong:
		return RichTextMarkBold
	case HtmlUnderline:
		return RichTextMarkUnderline
	case HtmlCode:
		return RichTextMarkCode
	}
	return ""
}

func richTextHtmlLinesToNode(htmlLines []string, start int, pendingTag string, marks []string, isBasic bool) ([]interface{}, int, bool) {
	nodeSlice := make([]interface{}, 0)
	for i := start; i < len(htmlLines); i++ {
		htmlLine := htmlLines[i]
		if richTextIsHtmlClosingPending(htmlLine, pendingTag) {
			return nodeSlice, i, isBasic
		}
		currentNode := RichTextNode{}
		if richTextIsHtmlTag(htmlLine) {
			tt := richTextHtmlTagType(htmlLine)
			switch tt {
			case HtmlParagraph, HtmlHeading1, HtmlHeading2, HtmlHeading3, HtmlHeading4, HtmlHeading5, HtmlHeading6, HtmlUnorderedList, HtmlOrderedList:
				isBasic = false
				currentNode.NodeType = richTextMapTagNodeType(tt)
				var nextLine int
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlBlockquote, HtmlListItem:
				isBasic = false
				currentNode.NodeType = richTextMapTagNodeType(tt)
				currentNode.Content = make([]interface{}, 0)
				innerContent, nextLine, isBasic := richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				currentNode.Content = append(currentNode.Content, RichTextNode{
					NodeType: RichTextNodeParagraph,
					Content:  innerContent,
				})
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlCode:
				isBasic = false
				currentNode.NodeType = RichTextNodeParagraph
				var nextLine int
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, HtmlCode, []string{HtmlCode}, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlAnchor:
				isBasic = false
				currentNode.NodeType = RichTextNodeHyperlink
				var nextLine int
				anchorURI := richTextGetAttribute(htmlLine, HtmlAttributeHref)
				if anchorURI == "" {
					anchorURI = "/"
				}
				currentNode.Data = RichTextData{URI: anchorURI}
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlHorizontalRule:
				isBasic = false
				currentNode.NodeType = RichTextNodeHR
				currentNode.Content = make([]interface{}, 0)
				nodeSlice = append(nodeSlice, currentNode)
			case HtmlItalic, HtmlEm, HtmlBold, HtmlStrong, HtmlUnderline:
				marks = append(marks, tt)
			case HtmlBreak:
				if len(nodeSlice) > 0 {
					myNode := nodeSlice[len(nodeSlice)-1]
					switch myNode.(type) {
					case RichTextNodeTextNode:
						myNodeTyped := myNode.(RichTextNodeTextNode)
						if myNodeTyped.NodeType == RichTextNodeText {
							myNodeTyped.Value += "\n"
							nodeSlice[len(nodeSlice)-1] = myNodeTyped
						}
					}
				}
			}
			continue //unsupported tags will be ignored but content is preserved
		}
		if richTextIsHtmlClosingTag(htmlLine) {
			continue //closing tags that are not pending equal to unknown
		}
		if htmlLine == " " {
			continue
		}
		currentNodeTextNode := RichTextNodeTextNode{}
		currentNodeTextNode.NodeType = RichTextNodeText
		currentNodeTextNode.Marks = []RichTextMark{}
		currentNodeTextNode.Value = htmlLine
		for _, mark := range marks {
			currentNodeTextNode.Marks = append(currentNodeTextNode.Marks, RichTextMark{
				Type: richTextGetMark(mark),
			})
		}
		marks = nil
		nodeSlice = append(nodeSlice, currentNodeTextNode)
	}
	return nodeSlice, -1, isBasic
}

func richTextIsHtmlClosingPending(htmlLine, tag string) bool {
	return regexp.MustCompile(`</` + strings.ToLower(tag) + `.+$`).MatchString(strings.ToLower(htmlLine))
}

func richTextIsHtmlClosingTag(htmlLine string) bool {
	return regexp.MustCompile(`</[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func richTextIsHtmlTag(htmlLine string) bool {
	return regexp.MustCompile(`<[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func richTextMapTagNodeType(tag string) string {
	switch tag {
	case HtmlParagraph:
		return RichTextNodeParagraph
	case HtmlAnchor:
		return RichTextNodeHyperlink
	case HtmlHeading1:
		return RichTextNodeHeading1
	case HtmlHeading2:
		return RichTextNodeHeading2
	case HtmlHeading3:
		return RichTextNodeHeading3
	case HtmlHeading4:
		return RichTextNodeHeading4
	case HtmlHeading5:
		return RichTextNodeHeading5
	case HtmlHeading6:
		return RichTextNodeHeading6
	case HtmlBlockquote:
		return RichTextNodeBlockquote
	case HtmlUnorderedList:
		return RichTextNodeUnorderedList
	case HtmlOrderedList:
		return RichTextNodeOrderedList
	case HtmlListItem:
		return RichTextNodeListItem
	}
	return ""
}

func (ts richTextHtmlTags) richTextHtmlTagsOpen(w io.Writer) {

	for _, t := range ts {
		tagString := "<" + t.name
		if len(t.attrs) > 0 {
			for name, value := range t.attrs {
				tagString += " " + name + `="` + html.EscapeString(value) + `"`
			}
		}
		w.Write([]byte(tagString + ">"))
	}
}

func (ts richTextHtmlTags) richTextHtmlTagsClose(w io.Writer) {
	for _, t := range ts {
		w.Write([]byte("</" + t.name + ">"))
	}
}

func richTextHtmlTagType(htmlLine string) string {
	re := regexp.MustCompile(`^<([a-zA-Z0-9]+)[\s]*>*`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func (n *RichTextGenericNode) richTextRenderHTML(w io.Writer, linkResolver LinkResolverFunc, entryLinkResolver EntryLinkResolverFunc, imageResolver ImageResolverFunc, locale Locale) (err error) {
	if linkResolver == nil {
		linkResolver = func(url string) (transformedAttrs map[string]string, err error) {
			return map[string]string{
				"href": url,
			}, nil
		}
	}
	if entryLinkResolver == nil {
		entryLinkResolver = func(entryID string, locale Locale) (transformedAttrs map[string]string, err error) {
			return map[string]string{}, nil
		}
	}
	tags := richTextHtmlTags{}

	switch n.NodeType {
	case RichTextNodeParagraph:
		tags = []richTextHtmlTag{ {name: HtmlParagraph} }
	case RichTextNodeHeading1:
		tags = []richTextHtmlTag{ {name: HtmlHeading1} }
	case RichTextNodeHeading2:
		tags = []richTextHtmlTag{ {name: HtmlHeading2} }
	case RichTextNodeHeading3:
		tags = []richTextHtmlTag{ {name: HtmlHeading3} }
	case RichTextNodeHeading4:
		tags = []richTextHtmlTag{ {name: HtmlHeading4} }
	case RichTextNodeHeading5:
		tags = []richTextHtmlTag{ {name: HtmlHeading5} }
	case RichTextNodeHeading6:
		tags = []richTextHtmlTag{ {name: HtmlHeading6} }
	case RichTextNodeOrderedList:
		tags = []richTextHtmlTag{ {name: HtmlOrderedList} }
	case RichTextNodeUnorderedList:
		tags = []richTextHtmlTag{ {name: HtmlUnorderedList} }
	case RichTextNodeListItem:
		tags = []richTextHtmlTag{ {name: HtmlListItem} }
	case RichTextNodeHR:
		tags = []richTextHtmlTag{ {name: HtmlHorizontalRule} }
	case RichTextNodeBlockquote:
		tags = []richTextHtmlTag{ {name: HtmlBlockquote} }
	case RichTextNodeText:
		tags = []richTextHtmlTag{}
	case RichTextNodeHyperlink:
		uri, _ := n.Data["uri"]
		attrs := map[string]string{}
		switch uri.(type) {
		case string:
			uriString := uri.(string)
			if uriString != "" {
				resolvedAttrs, errResolveAttrs := linkResolver(uriString)
				if errResolveAttrs != nil {
					err = errResolveAttrs
					return
				}
				attrs = resolvedAttrs
			}
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlAnchor, attrs: attrs}}
	case RichTextNodeEntryHyperlink:
		target, _ := n.Data["target"]
		attrs := map[string]string{}
		switch target.(type) {
		case map[string]interface{}:
			targetSys, ok := target.(map[string]interface{})["sys"]
			if ok {
				entryID := targetSys.(map[string]interface{})["id"].(string)
				resolvedAttrs, errResolveAttrs := entryLinkResolver(entryID, locale)
				if errResolveAttrs != nil {
					err = errResolveAttrs
					return
				}
				attrs = resolvedAttrs
			}
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlAnchor, attrs: attrs}}
	case RichTextNodeEmbeddedAsset:
		if imageResolver == nil {
			return errors.New("Can't resolve image asset URL")
		}
		dataObj := RichTextData{}
		byt, err := json.Marshal(n.Data)
		if err != nil {
			return err
		}
		err = json.Unmarshal(byt, &dataObj)
		if dataObj.Target == nil {
			return errors.New("Data target is empty")
		}
		attrs, err := imageResolver(dataObj.Target.Sys.ID, locale)
		if err != nil {
			return err
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlImage, attrs: attrs}}
	default:
	}
	for _, m := range n.Marks {
		markTag := ""
		switch m.Type {
		case RichTextMarkBold:
			markTag = HtmlBold
		case RichTextMarkItalic:
			markTag = HtmlItalic
		case RichTextMarkUnderline:
			markTag = HtmlUnderline
		case RichTextMarkCode:
			markTag = HtmlCode
		case RichTextNodeBlockquote:
			markTag = HtmlBlockquote
		}
		if markTag != "" {
			tags = append(tags, richTextHtmlTag{name: markTag})
		}
	}

	tags.richTextHtmlTagsOpen(w)
	w.Write([]byte(strings.Replace(html.EscapeString(n.Value), "\n", "<br/>", -1)))
	for _, subNode := range n.Content {
		errSubNode := subNode.richTextRenderHTML(w, linkResolver, entryLinkResolver, imageResolver, locale)
		if errSubNode != nil {
			err = errSubNode
			return
		}
	}
	tags.richTextHtmlTagsClose(w)
	return
}

func stringSliceContains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func updateCacheForContentType(ctx context.Context, results chan ContentTypeResult, cc *ContentfulClient, tempCache *ContentfulCache, contentType string) error {
	if ctx.Err() != nil {
		return ctx.Err()
	}
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		all{{ firstCap $contentType.Sys.ID }}, err := cc.cacheAll{{ firstCap $contentType.Sys.ID }}(ctx, results)
		if err != nil {
			return err
		}
		tempCache.entryMaps.{{ $contentType.Sys.ID }} = all{{ firstCap $contentType.Sys.ID }}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType":"{{ $contentType.Sys.ID }}", "method": "updateCacheForContentType", "size":len(all{{ firstCap $contentType.Sys.ID }})}, LogInfo, InfoCachedAllEntries)
		}
	{{ end }}
	case assetWorkerType:
		allAssets, err := cc.getAllAssets(false)
		if err != nil {
			return err
		}
		tempCache.assets = allAssets
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "asset", "method": "updateCacheForContentType", "size": len(allAssets)}, LogInfo, InfoCachedAllAssets)
		}
	}
	return nil
}

func updateCacheForContentTypeAndEntity(ctx context.Context, cc *ContentfulClient, sysType string, contentType string, entityID string) error {
	if ctx.Err() != nil {
		return ctx.Err()
	}
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		err := cc.cache{{ firstCap $contentType.Sys.ID }}ByID(ctx, entityID)
		if err != nil {
			return err
		}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "{{ $contentType.Sys.ID }}", "method": "updateCacheForContentType", "entityID": entityID}, LogInfo, InfoUpdatedEntityCache)
		}
	{{ end }}
	}
	return nil
}

