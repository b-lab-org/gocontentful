// Package {{ .PackageName }} - DO NOT EDIT THIS FILE: Auto-generated code by https://github.com/foomo/gocontentful
{{ $cfg := . }}{{ $contentTypes := .ContentTypes }}{{ $locales := .Locales }}package {{ .PackageName }}

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"io/ioutil"
	"regexp"
	"strings"
	"sync"
	"time"
	"github.com/foomo/contentful"
	"golang.org/x/sync/errgroup"
)

type cacheEntryMaps struct {
	{{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }} map[string]*Cf{{ firstCap $contentType.Sys.ID }}
	{{ end }}
}

type ClientMode string

type ContentfulCache struct {
	assets                 assetCacheMap
	contentTypes           []string
	entryMaps              cacheEntryMaps
	idContentTypeMap       map[string]string
	parentMap              map[string][]EntryReference
}

type ContentfulCacheMutex struct {
	fullCacheGcLock        sync.RWMutex
	sharedDataGcLock       sync.RWMutex
	assetsGcLock           sync.RWMutex
	idContentTypeMapGcLock sync.RWMutex
	parentMapGcLock        sync.RWMutex
	{{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }}GcLock sync.RWMutex
    {{ end }}
}

type assetCacheMap map[string]*contentful.Asset

type ContentfulClient struct {
	Cache  *ContentfulCache
	CacheMutex *ContentfulCacheMutex
	clientMode ClientMode
	Client     *contentful.Contentful
	locales    []Locale
	logFn      func(
			fields map[string]interface{},
			level int,
			args ...interface{},
	)
	logLevel           int
	optimisticPageSize uint16 // Start downloading entries at this page size
	SpaceID            string
	offline            bool
	offlineTemp        offlineTemp
}

type offlineTemp struct {
	Entries []contentful.Entry `json:"entries"`
	Assets  []contentful.Asset `json:"assets"`
}

type ContentTypeResult struct {
	EntryID     string
	ContentType string
	References  map[string][]EntryReference
}

type ContentTypeInfo struct {
	ContentType string
	Title       string
	Description string
}

type ContentTypeInfoMap map[string]ContentTypeInfo

type EntryReference struct {
	ContentType string
	ID string
	VO interface{}
	FromField   string
}

type BrokenReference struct {
	ParentID   string `json:"parentId"`
	ParentType string `json:"parentType"`
	FromField  string `json:"fromField"`
	ChildID    string `json:"childId"`
}


type ImageResolverFunc func(assetID string, locale Locale) (attrs map[string]string, customHTML string, resolveError error)
type EntryLinkResolverFunc func(entryID string, locale Locale) (resolvedAttrs map[string]string, resolveError error)
type LinkResolverFunc func(url string) (resolvedAttrs map[string]string, resolveError error)
type EmbeddedEntryResolverFunc func(entryID string, locale Locale) (htmlSnippet string, resolveError error)

type Locale string

const (
	ClientModeCDA ClientMode = "CDA"
	ClientModeCPA ClientMode = "CPA"
	ClientModeCMA ClientMode = "CMA"
)

const (
	LogDebug = 0
	LogInfo = 1
	LogWarn = 2
	LogError = 3
)

{{ range $index , $locale := $locales }}const SpaceLocale{{ onlyLetters $locale.Name }} Locale = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale Locale = SpaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var localeFallback = map[Locale]Locale{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} SpaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}SpaceLocale{{ onlyLetters $localeSearch.Name }}{{ end }}{{ end }}, {{ else }}SpaceLocale{{ onlyLetters $locale.Name }}: "", {{ end }}{{ end }}}

const (
	assetPageSize = 1000
	assetWorkerType = "_asset"
)

const cacheUpdateConcurrency = 4

const (
	sysTypeEntry = "Entry"
	sysTypeAsset = "Asset"
)

var (
	ErrLocaleUnsupported        = errors.New("locale not supported by this space")
	ErrNotSet                   = errors.New("field value not set")
	ErrNotSetNoFallback         = errors.New("field value not set and no fallback locale available")
	ErrRefNotIncludes           = errors.New("referenced entry not found in includes")
	ErrNoTypeOfRefEntry         = errors.New("couldn't get contentType of referenced entry")
	ErrNoTypeOfRefAsset         = errors.New("couldn't get contentType of referenced asset")
	InfoUpdatedEntityCache      = "updated cache for entity"
	InfoCachedAllEntries        = "cached all entries of content type"
	InfoCachedAllAssets         = "cached all assets"
	InfoFallingBackToFile       = "could not download space data from Contentful, falling back to local file"
	InfoLoadingFromFile         = "loading space from local file"
	InfoOfflineEntitiesLoaded   = "downloaded entries and assets from offline file"
	InfoPreservingExistingCache = "could not connect for cache update, preserving the existing cache"
	InfoUpdateCacheTime         = "space caching done, time recorded"
)

var spaceContentTypes = []string{ {{ range $index , $contentType := $contentTypes }}ContentType{{ firstCap $contentType.Sys.ID }}, {{ end }} }
var SpaceContentTypeInfoMap = ContentTypeInfoMap{ {{ range $index , $contentType := $contentTypes }}
    "{{ $contentType.Sys.ID }}": ContentTypeInfo{
            ContentType: "{{ $contentType.Sys.ID }}",
            Title:       "{{ $contentType.Name }}",
            Description: "{{ $contentType.Description }}",
        },{{ end }}
}
func (cc *ContentfulClient) BrokenReferences() (brokenReferences []BrokenReference) {
    if cc.Cache == nil || cc.CacheMutex == nil {
        return
    }
    cc.CacheMutex.parentMapGcLock.Lock()
    defer cc.CacheMutex.parentMapGcLock.Unlock()
    cc.CacheMutex.idContentTypeMapGcLock.Lock()
    defer cc.CacheMutex.idContentTypeMapGcLock.Unlock()
    for childID, parents := range cc.Cache.parentMap {
		if _, okGotEntry := cc.Cache.idContentTypeMap[childID]; !okGotEntry {
			for _, parent := range parents {
				brokenReferences = append(brokenReferences, BrokenReference{
					ParentID:   parent.ID,
					ParentType: parent.ContentType,
					FromField:  parent.FromField,
					ChildID:    childID,
				})
			}
		}
	}
	return
}

func (cc *ContentfulClient) CacheHasContentType(contentTypeID string) bool {
	if cc.Cache == nil {
		return false
	}
	for _, cachedContentType := range cc.Cache.contentTypes {
		if cachedContentType == contentTypeID {
			return true
		}
	}
	return false
}

func (cc *ContentfulClient) ClientStats() {
	if cc == nil {
		cc.logFn(nil, LogWarn, "ClientStats: no client available")
		return
	}
	if cc.logFn != nil {
		cached := false
		if cc.Cache != nil {
			cached = true
		}
		fieldsMap := map[string]interface{}{
			"space ID":     cc.SpaceID,
			"environment":  cc.Client.Environment,
			"clientMode":   cc.clientMode,
			"contentTypes": strings.Join(cc.Cache.contentTypes, ","),
			"locales":      cc.locales,
			"cached":       cached,
		}
		if cached {
			fieldsMap["cache asset count"] = len(cc.Cache.assets)
			fieldsMap["cache entry count"] = len(cc.Cache.idContentTypeMap)
			fieldsMap["cache parentMap length"] = len(cc.Cache.parentMap)
		}
		cc.logFn(fieldsMap, LogInfo, "Contentful ClientStats")
	}
}

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}

func (cc *ContentfulClient) DeleteAsset(asset *contentful.Asset) error {
	if cc == nil || cc.Client == nil {
		return errors.New("DeleteAsset: No client available")
	}
	if cc.clientMode != ClientModeCMA {
		return errors.New("DeleteAsset: Only available in ClientModeCMA")
	}
	errUnpublish := cc.Client.Assets.Unpublish(cc.SpaceID, asset)
	if errUnpublish != nil && !strings.Contains(errUnpublish.Error(), "Not published") {
		return errUnpublish
	}
	errDelete := cc.Client.Assets.Delete(cc.SpaceID, asset)
	if errDelete != nil {
		return errDelete
	}
	return nil
}

func (cc *ContentfulClient) DeleteAssetFromCache(key string) error {
	return cc.deleteAssetFromCache(key)
}

func (cc *ContentfulClient) GetAllAssets() (map[string]*contentful.Asset, error) {
	return cc.getAllAssets(true)
}

func (cc *ContentfulClient) GetAssetByID(id string, forceNoCache ...bool) (*contentful.Asset, error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("GetAssetByID: No client available")
	}
	if cc.Cache != nil && cc.Cache.assets != nil && (len(forceNoCache) == 0 || !forceNoCache[0]) {
		cc.CacheMutex.assetsGcLock.Lock()
		asset, okAsset := cc.Cache.assets[id]
		cc.CacheMutex.assetsGcLock.Unlock()
		if okAsset {
			return asset, nil
		}
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Equal("sys.id",id)
	_, err := col.Next()
	if err != nil {
		return nil, err
	}
	if len(col.Items) == 0 {
		return nil, errors.New("GetAssetByID: Not found "+ id)
	}
	item := col.Items[0]
	asset := contentful.Asset{}
	byt, err := json.Marshal(item)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(byt, &asset)
	if err != nil {
		return nil, err
	}
	for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
		if _, ok := asset.Fields.File[string(loc)]; ok {
			asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
		}
	}
	return &asset, nil
}

func (cc *ContentfulClient) GetContentTypeOfID(id string) (string, error) {
	if cc == nil || cc.Client == nil {
		return "", errors.New("GetContentTypeOfID: No client available")
	}
	if cc.Cache != nil && cc.CacheMutex != nil {
		okVo := false
		{{ range $index , $contentType := $contentTypes }}
		cc.CacheMutex.{{ $contentType.Sys.ID }}GcLock.Lock()
		_, okVo = cc.Cache.entryMaps.{{ $contentType.Sys.ID }}[id]
		cc.CacheMutex.{{ $contentType.Sys.ID }}GcLock.Unlock()
		if okVo {
			return ContentType{{ firstCap $contentType.Sys.ID }}, nil
		}
		{{ end }}
		return "", fmt.Errorf("GetContentTypeOfID: %s Not found in cache", id)
	}
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.Include(0).Equal("sys.id",id)
	_, err := col.GetAll()
	if err != nil {
		return "", errors.New("GetContentTypeOfID: "+err.Error())
	}
	if len(col.Items) == 0 {
		return "", fmt.Errorf("GetContentTypeOfID: %s Not found online", id)
	}
	var vo genericEntryNoFields
	byteArray, _ := json.Marshal(col.Items[0])
	err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
	if err != nil {
		return "", errors.New("GetContentTypeOfID: "+err.Error())
	}
	return vo.Sys.ContentType.Sys.ID, nil
}

func (ref *EntryReference) GetParents(cc *ContentfulClient) (parents []EntryReference, err error) {
	if ref == nil {
		return nil, errors.New("GetParents: reference is nil!")
	}
	if cc == nil {
		return nil, errors.New("GetParents: Contentful client is nil!")
	}
	if cc.Cache == nil {
		return nil, errors.New("GetParents: only available in cached mode")
	}
	return cc.Cache.parentMap[ref.ID], nil
}

func HtmlToRichText(htmlSrc string) *RichTextNode {
	htmlClean := strings.TrimSpace(htmlSrc)
	htmlClean = strings.ReplaceAll(htmlClean, `&nbsp;`, ` `)
	htmlClean = strings.ReplaceAll(htmlClean, "&amp;", "&")
    htmlClean = strings.ReplaceAll(htmlClean, "\t", "")
	htmlClean = regexp.MustCompile(`[\s]{2,}`).ReplaceAllString(htmlClean, " ")
	re := regexp.MustCompile(`>([^\n])`)
	htmlClean = re.ReplaceAllString(htmlClean, fmt.Sprintf(">\n"+`$1`))
	re = regexp.MustCompile(`(.{1})<`)
	htmlClean = re.ReplaceAllString(htmlClean, `$1`+fmt.Sprintf("\n<"))
	htmlLines := strings.Split(htmlClean, "\n")
	rtnd := &RichTextNode{
		NodeType: RichTextNodeDocument,
	}
	var isBasic bool
	rtnd.Content, _, isBasic = richTextHtmlLinesToNode(htmlLines, 0, "", nil, true)
	if isBasic {
        basicRich := &RichTextNode{
            NodeType: RichTextNodeDocument,
            Content:  rtnd.Content,
        }
        return basicRich
    }
	return rtnd
}

func NewAssetFromURL(id string, uploadUrl string, imageFileType string, title string, locale ...Locale) *contentful.Asset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc Locale
	if len(locale) != 0 {
		loc = locale[0]
		if localeFallback[loc]!="" {
			return nil
		}
	} else {
		loc = defaultLocale
	}
	asset := &contentful.Asset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				string(loc): {
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				string(loc): title,
			},
		},
	}
	return asset
}

func NewContentfulClient(spaceID string, clientMode ClientMode, clientKey string, optimisticPageSize uint16, logFn func(fields map[string]interface{}, level int, args ...interface{}), logLevel int, debug bool) (*ContentfulClient, error) {
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	if clientMode != ClientModeCMA && clientMode != ClientModeCPA && clientMode != ClientModeCDA {
		return nil, errors.New("NewContentfulClient: clientMode not supported")
	}
	if optimisticPageSize < 10 {
		return nil, errors.New("NewContentfulClient: optimisticPageSize must be 10 or bigger")
	}
	if logLevel < 0 || logLevel > 3 {
		return nil, errors.New("NewContentfulClient: logLevel must be between 0 and 3")
	}
	if clientKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide an API key")
	}
	apiClient, err := getContentfulAPIClient(clientMode, clientKey)
	if err != nil {
		return nil, err
	}
	apiClient.Debug = debug
	cc := &ContentfulClient{
		clientMode:         clientMode,
		Client:             apiClient,
		locales:			[]Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }}, {{ end }} },
		logFn:              logFn,
		logLevel:           logLevel,
		optimisticPageSize: optimisticPageSize,
		SpaceID:            spaceID,
	}
	_, err = cc.Client.Spaces.Get(spaceID)
	if err != nil {
		_, ok := err.(contentful.NotFoundError)
		if ok {
			return nil, errors.New("NewContentfulClient: That is not the space you're looking for")
		}
		return nil, errors.New("NewContentfulClient: "+err.Error())
	}
	return cc, nil
}

func NewOfflineContentfulClient(filename string, logFn func(fields map[string]interface{}, level int, args ...interface{}), logLevel int, cacheAssets bool) (*ContentfulClient, error) {
	offlineTemp, err := getOfflineSpaceFromFile(filename)
	if err != nil {
		return nil, fmt.Errorf("NewOfflineContentfulClient could not parse space export file: %v", err)
	}
	cc := &ContentfulClient{
		clientMode:  ClientModeCDA,
		Client:      contentful.NewCDA(""),
		locales:     []Locale{
			{{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},
{{ end}}},
		logFn:       logFn,
		logLevel:    logLevel,
		SpaceID:     "OFFLINE",
		offline:     true,
		offlineTemp: *offlineTemp,
	}
	if cc.logFn != nil && cc.logLevel <= LogInfo {
        cc.logFn(map[string]interface{}{"entries": len(offlineTemp.Entries),"assets": len(offlineTemp.Assets)}, LogInfo, InfoLoadingFromFile)
    }
	err = cc.UpdateCache(context.TODO(), spaceContentTypes, cacheAssets)
	if err != nil {
		return nil, fmt.Errorf("NewOfflineContentfulClient could not cache offline space: %v", err)
	}
	return cc, nil
}

func RichTextToHtml(rt interface{}, linkResolver LinkResolverFunc, entryLinkResolver EntryLinkResolverFunc, imageResolver ImageResolverFunc, embeddedEntryResolver EmbeddedEntryResolverFunc, locale Locale) (string, error) {
	w := bytes.NewBuffer([]byte{})
	node := &RichTextGenericNode{}
	byt, err := json.Marshal(rt)
	if err != nil {
		return "", err
	}
	err = json.Unmarshal(byt, node)
	if err != nil {
		return "", err
	}
	err = node.richTextRenderHTML(w, linkResolver, entryLinkResolver, imageResolver, embeddedEntryResolver, locale)
	if err != nil {
		return "", err
	}
	out := string(w.Bytes())
	if out == "<p></p>" {
		return "", nil
	}
	return out, nil
}

func (cc *ContentfulClient) SetEnvironment(environment string) {
	cc.Client.Environment = environment
	return
}

func (cc *ContentfulClient) SetOfflineFallback(filename string) error {
	offlineTemp, err := getOfflineSpaceFromFile(filename)
	if err != nil {
		return err
	}
	cc.offlineTemp = *offlineTemp
	return nil
}

func (cc *ContentfulClient) UpdateCache(ctx context.Context, contentTypes []string, cacheAssets bool) error {
	start := time.Now()
	if contentTypes == nil {
		contentTypes = spaceContentTypes
	} else {
		for _, contentType := range contentTypes {
			if !stringSliceContains(spaceContentTypes, contentType) {
				return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
			}
		}
	}
	if cc.CacheMutex == nil {
		cc.CacheMutex = &ContentfulCacheMutex{
			fullCacheGcLock:        sync.RWMutex{},
			sharedDataGcLock:       sync.RWMutex{},
			assetsGcLock:           sync.RWMutex{},
			idContentTypeMapGcLock: sync.RWMutex{},
			parentMapGcLock:        sync.RWMutex{},
			{{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }}GcLock: sync.RWMutex{},
            {{ end }}
		}
	}
	tempCache := &ContentfulCache{
		contentTypes:     contentTypes,
		idContentTypeMap: map[string]string{},
		parentMap:        map[string][]EntryReference{},
	}
	if cacheAssets {
		contentTypes = append([]string{assetWorkerType}, contentTypes...)
	}
	_, errCanWeEvenConnect := cc.Client.Spaces.Get(cc.SpaceID)
	cc.CacheMutex.sharedDataGcLock.RLock()
    offlinePreviousState := cc.offline
 	cc.CacheMutex.sharedDataGcLock.RUnlock()
	if errCanWeEvenConnect != nil {
		if len(cc.offlineTemp.Entries) > 0 && (cc.Cache == nil || offlinePreviousState == true) {
			if cc.logFn != nil && cc.logLevel <= LogInfo {
				cc.logFn(map[string]interface{}{"method": "UpdateCache"}, LogInfo, InfoFallingBackToFile)
			}
			cc.CacheMutex.sharedDataGcLock.Lock()
			cc.offline = true
			cc.CacheMutex.sharedDataGcLock.Unlock()
		} else {
			if cc.logFn != nil && cc.logLevel <= LogInfo {
				cc.logFn(map[string]interface{}{"method": "UpdateCache"}, LogInfo, InfoPreservingExistingCache)
			}
		}
	}
    results := make(chan ContentTypeResult, 16)
	resultsDone := make(chan struct{})
	contentTypeChan := make(chan string)
	group, gctx := errgroup.WithContext(ctx)
	for i := 0; i < cacheUpdateConcurrency; i++ {
		group.Go(func() error {
			for contentType := range contentTypeChan {
				err := updateCacheForContentType(gctx, results, cc, tempCache, contentType)
				if err != nil {
					if cc.logFn != nil && cc.logLevel <= LogInfo {
                        cc.logFn(map[string]interface{}{"method": "UpdateCache", "contentType": contentType}, LogError, err.Error())
                    }
					return err
				}
			}
			return nil
		})
	}
	go func() {
		for _, contentType := range contentTypes {
			contentTypeChan <- contentType
		}
		close(contentTypeChan)
	}()
	go func() {
		for res := range results {
			tempCache.idContentTypeMap[res.EntryID] = res.ContentType
			for childID, references := range res.References {
				tempCache.parentMap[childID] = append(tempCache.parentMap[childID], references...)
			}
		}
		resultsDone <- struct{}{}
	}()
	err := group.Wait()
	close(results)
	if err != nil {
		// drain contentTypeChan
		for _ = range contentTypeChan {	}
		cc.CacheMutex.sharedDataGcLock.Lock()
		cc.offline = offlinePreviousState
		cc.CacheMutex.sharedDataGcLock.Unlock()
        return err
	}
	// Signal that the cache build is done
	<-resultsDone

	if cc.logFn != nil && cc.logLevel <= LogInfo {
		cc.logFn(map[string]interface{}{"time elapsed":fmt.Sprint(time.Since(start)), "method": "UpdateCache"}, LogInfo, InfoUpdateCacheTime)
	}
	cc.CacheMutex.fullCacheGcLock.Lock()
	defer cc.CacheMutex.fullCacheGcLock.Unlock()
	cc.Cache = tempCache
	cc.CacheMutex.sharedDataGcLock.Lock()
	cc.offline = offlinePreviousState
	cc.CacheMutex.sharedDataGcLock.Unlock()
	return nil
}

func ToAssetReference(asset *contentful.Asset) (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeAsset
	return
}

func (cc *ContentfulClient) UpdateCacheForEntity(ctx context.Context, sysType string, contentType string, entityID string) error {
	if sysType == sysTypeEntry && cc.entryMapForContentTypeIsNil(contentType) {
		return fmt.Errorf("UpdateCacheForEntity: Content Type %q not available in cache", contentType)
	}
	if sysType == sysTypeAsset {
		contentType = assetWorkerType
	}
	if contentType != assetWorkerType && !stringSliceContains(spaceContentTypes, contentType) {
		return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
	}
	err := updateCacheForContentTypeAndEntity(ctx, cc, sysType, contentType, entityID)
	if err != nil {
		return err
	}
	return nil
}

func FieldToObject(jsonField interface{}, targetObject interface{}) error {
	byteArray, err := json.Marshal(jsonField)
	if err != nil {
		return err
	}
	err = json.Unmarshal(byteArray, &targetObject)
	if err != nil {
		return err
	}
	return nil
}

func (cc *ContentfulClient) cacheGcAssetByID(ctx context.Context, id string) error {
	if cc == nil || cc.Client == nil {
		return errors.New("cacheGcAssetByID: No client available")
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Equal("sys.id", id)
	_, err := col.Next()
	if err != nil {
		return err
	}
	if len(col.Items) == 0 {
		return errors.New("cacheGcAssetByID: Not found " + id)
	}
	item := col.Items[0]
	asset := contentful.Asset{}
	byt, err := json.Marshal(item)
	if err != nil {
		return err
	}
	err = json.Unmarshal(byt, &asset)
	if err != nil {
		return err
	}
	for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
		if _, ok := asset.Fields.File[string(loc)]; ok {
			asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
		}
	}
	cc.CacheMutex.assetsGcLock.Lock()
	cc.Cache.assets[id] = &asset
	cc.CacheMutex.assetsGcLock.Unlock()
	return nil
}

func (cc *ContentfulClient) deleteAssetFromCache(key string) error {
	if cc.Cache == nil || cc.CacheMutex == nil {
    		return errors.New("no cache available")
    	}
    cc.CacheMutex.assetsGcLock.Lock()
	if _, ok := cc.Cache.assets[key]; ok {
		delete(cc.Cache.assets, key)
		cc.CacheMutex.assetsGcLock.Unlock()
		return nil
	}
	cc.CacheMutex.assetsGcLock.Unlock()
	return errors.New("asset not found in cache, could not delete")
}

func (cc *ContentfulClient) entryMapForContentTypeIsNil(contentType string) bool {
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		if cc.Cache.entryMaps.{{ $contentType.Sys.ID }} == nil {
		return true
	}
	{{ end }}
	}
	return false
}

func getContentfulAPIClient(clientMode ClientMode, clientKey string) (*contentful.Contentful, error) {
	switch clientMode {
	case ClientModeCDA:
		return contentful.NewCDA(clientKey), nil
	case ClientModeCPA:
		return contentful.NewCPA(clientKey), nil
	case ClientModeCMA:
		return contentful.NewCMA(clientKey), nil
	default:
		return nil, errors.New("NewContentfulClient: Unknown ClientMode")
	}
}

func (cc *ContentfulClient) getAllAssets(tryCacheFirst bool) (map[string]*contentful.Asset, error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("getAllAssets: No client available")
	}
	if cc.Cache != nil && cc.Cache.assets != nil && tryCacheFirst {
		return cc.Cache.assets, nil
	}
	allItems := []interface{}{}
	assets := map[string]*contentful.Asset{}
	if cc.offline {
		for _, asset := range cc.offlineTemp.Assets {
			allItems = append(allItems,asset)
		}
	} else {
		col := cc.Client.Assets.List(cc.SpaceID)
		col.Query.Locale("*").Limit(assetPageSize)
		for {
			_, err := col.Next()
			if err != nil {
				return nil, err
			}
			allItems = append(allItems, col.Items...)
			if uint16(len(col.Items)) < assetPageSize {
				break
			}
		}
	}
	for _, item := range allItems {
		asset := contentful.Asset{}
		byt, err := json.Marshal(item)
		if err != nil {
			return nil, err
		}
		err = json.Unmarshal(byt, &asset)
		if err != nil {
			return nil, err
		}
		for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
			if _, ok := asset.Fields.File[string(loc)]; ok {
				asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
			}
		}
		assets[asset.Sys.ID] = &asset
	}
	return assets, nil
}

func getOfflineSpaceFromFile(filename string) (*offlineTemp, error) {
	fileBytes, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("getOfflineSpaceFromFile could not read space export file: %v", err)
	}
	offlineTemp := &offlineTemp{}
	err = json.Unmarshal(fileBytes, offlineTemp)
	if err != nil {
		return nil, fmt.Errorf("getOfflineSpaceFromFile could not parse space export file: %v", err)
	}
	return offlineTemp, nil
}

func (cc *ContentfulClient) optimisticPageSizeGetAll(contentType string, limit uint16) (*contentful.Collection, error) {
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.ContentType(contentType).Locale("*").Include(0).Limit(limit)
	allItems := []interface{}{}
	var err error
	for {
		_, err = col.Next()
		if err != nil {
			break
		}
		allItems = append(allItems, col.Items...)
		if uint16(len(col.Items)) < limit {
			break
		}
	}
	col.Items = allItems
	switch err.(type) {
	case contentful.ErrorResponse:
		msg := err.(contentful.ErrorResponse).Message
		if strings.Contains(msg, "Response size too big") && limit >= 20 {
			smallerPageCol, err := cc.optimisticPageSizeGetAll(contentType, limit/2)
			return smallerPageCol, err
		}
		return nil, err
	case nil:
	default:
		return nil, err
	}
	return col, nil
}

func richTextGetAttribute(htmlLine string, attribute string) string {
	re := regexp.MustCompile(` href=["']([^"']+)["']`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func richTextGetMark(mark string) string {
	switch mark {
	case HtmlItalic, HtmlEm:
		return RichTextMarkItalic
	case HtmlBold, HtmlStrong:
		return RichTextMarkBold
	case HtmlUnderline:
		return RichTextMarkUnderline
	case HtmlCode:
		return RichTextMarkCode
	}
	return ""
}

func richTextHtmlLinesToNode(htmlLines []string, start int, pendingTag string, marks []string, isBasic bool) ([]interface{}, int, bool) {
	nodeSlice := make([]interface{}, 0)
	for i := start; i < len(htmlLines); i++ {
		htmlLine := htmlLines[i]
		if richTextIsHtmlClosingPending(htmlLine, pendingTag) {
			return nodeSlice, i, isBasic
		}
		currentNode := RichTextNode{}
		if richTextIsHtmlTag(htmlLine) {
			tt := richTextHtmlTagType(htmlLine)
			switch tt {
			case HtmlParagraph, HtmlHeading1, HtmlHeading2, HtmlHeading3, HtmlHeading4, HtmlHeading5, HtmlHeading6, HtmlUnorderedList, HtmlOrderedList:
				isBasic = false
				currentNode.NodeType = richTextMapTagNodeType(tt)
				var nextLine int
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlBlockquote, HtmlListItem:
				isBasic = false
				currentNode.NodeType = richTextMapTagNodeType(tt)
				currentNode.Content = make([]interface{}, 0)
				innerContent, nextLine, isBasic := richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				if len(innerContent) == 1 {
                    switch innerContent[0].(type) {
                    case RichTextNodeTextNode:
                        currentNode.Content = append(currentNode.Content, RichTextNode{
                            NodeType: RichTextNodeParagraph,
                            Content:  innerContent,
                        })
                    }
                } else {
                    for _, ct := range innerContent {
                        switch ct.(type) {
                        case RichTextNode:
                            currentNode.Content = append(currentNode.Content, ct)
                        case RichTextNodeTextNode:
                            currentNode.Content = append(currentNode.Content, RichTextNode{
                                NodeType: RichTextNodeParagraph,
                                Content:  []interface{}{ct},
                            })
                        }
                    }
                }
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlCode:
				isBasic = false
				currentNode.NodeType = RichTextNodeParagraph
				var nextLine int
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, HtmlCode, []string{HtmlCode}, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlAnchor:
				isBasic = false
				currentNode.NodeType = RichTextNodeHyperlink
				var nextLine int
				anchorURI := richTextGetAttribute(htmlLine, HtmlAttributeHref)
				if anchorURI == "" {
					anchorURI = "/"
				}
				currentNode.Data = RichTextData{URI: anchorURI}
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlHorizontalRule:
				isBasic = false
				currentNode.NodeType = RichTextNodeHR
				currentNode.Content = make([]interface{}, 0)
				nodeSlice = append(nodeSlice, currentNode)
			case HtmlItalic, HtmlEm, HtmlBold, HtmlStrong, HtmlUnderline:
				marks = append(marks, tt)
			case HtmlBreak:
				if len(nodeSlice) > 0 {
					myNode := nodeSlice[len(nodeSlice)-1]
					switch myNode.(type) {
					case RichTextNodeTextNode:
						myNodeTyped := myNode.(RichTextNodeTextNode)
						if myNodeTyped.NodeType == RichTextNodeText {
							myNodeTyped.Value += "\n"
							nodeSlice[len(nodeSlice)-1] = myNodeTyped
						}
					}
				}
			}
			continue //unsupported tags will be ignored but content is preserved
		}
		if richTextIsHtmlClosingTag(htmlLine) {
			continue //closing tags that are not pending equal to unknown
		}
		if htmlLine == " " {
			continue
		}
		currentNodeTextNode := RichTextNodeTextNode{}
		currentNodeTextNode.NodeType = RichTextNodeText
		currentNodeTextNode.Marks = []RichTextMark{}
		currentNodeTextNode.Value = htmlLine
		for _, mark := range marks {
			currentNodeTextNode.Marks = append(currentNodeTextNode.Marks, RichTextMark{
				Type: richTextGetMark(mark),
			})
		}
		marks = nil
        if pendingTag == "" {
            nodeSlice = append(nodeSlice, RichTextNode{
                NodeType: RichTextNodeParagraph,
                Content:  []interface{}{currentNodeTextNode},
            })
        } else {
            nodeSlice = append(nodeSlice, currentNodeTextNode)
        }
	}
	return nodeSlice, -1, isBasic
}

func richTextIsHtmlClosingPending(htmlLine, tag string) bool {
	return regexp.MustCompile(`</` + strings.ToLower(tag) + `.+$`).MatchString(strings.ToLower(htmlLine))
}

func richTextIsHtmlClosingTag(htmlLine string) bool {
	return regexp.MustCompile(`</[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func richTextIsHtmlTag(htmlLine string) bool {
	return regexp.MustCompile(`<[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func richTextMapTagNodeType(tag string) string {
	switch tag {
	case HtmlParagraph:
		return RichTextNodeParagraph
	case HtmlAnchor:
		return RichTextNodeHyperlink
	case HtmlHeading1:
		return RichTextNodeHeading1
	case HtmlHeading2:
		return RichTextNodeHeading2
	case HtmlHeading3:
		return RichTextNodeHeading3
	case HtmlHeading4:
		return RichTextNodeHeading4
	case HtmlHeading5:
		return RichTextNodeHeading5
	case HtmlHeading6:
		return RichTextNodeHeading6
	case HtmlBlockquote:
		return RichTextNodeBlockquote
	case HtmlUnorderedList:
		return RichTextNodeUnorderedList
	case HtmlOrderedList:
		return RichTextNodeOrderedList
	case HtmlListItem:
		return RichTextNodeListItem
	}
	return ""
}

func (ts richTextHtmlTags) richTextHtmlTagsOpen(w io.Writer) {

	for _, t := range ts {
		if t.customHTML != "" {
			w.Write([]byte(t.customHTML))
			continue
		}
		tagString := "<" + t.name
		if len(t.attrs) > 0 {
			for name, value := range t.attrs {
				tagString += " " + name + `="` + html.EscapeString(value) + `"`
			}
		}
		w.Write([]byte(tagString + ">"))
	}
}

func (ts richTextHtmlTags) richTextHtmlTagsClose(w io.Writer) {
	for _, t := range ts {
		if t.customHTML != "" {
			continue
		}
		w.Write([]byte("</" + t.name + ">"))
	}
}

func richTextHtmlTagType(htmlLine string) string {
	re := regexp.MustCompile(`^<([a-zA-Z0-9]+)[\s]*>*`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func (n *RichTextGenericNode) richTextRenderHTML(w io.Writer, linkResolver LinkResolverFunc, entryLinkResolver EntryLinkResolverFunc, imageResolver ImageResolverFunc, embeddedEntryResolver EmbeddedEntryResolverFunc, locale Locale) (err error) {
	if linkResolver == nil {
		linkResolver = func(url string) (transformedAttrs map[string]string, err error) {
			return map[string]string{
				"href": url,
			}, nil
		}
	}
	if entryLinkResolver == nil {
		entryLinkResolver = func(entryID string, locale Locale) (transformedAttrs map[string]string, err error) {
			return map[string]string{}, nil
		}
	}
	if embeddedEntryResolver == nil {
		embeddedEntryResolver = func(entryID string, locale Locale) (htmlSnippet string, err error) {
			return "", nil
		}
	}
	tags := richTextHtmlTags{}
	switch n.NodeType {
	case RichTextNodeParagraph:
		tags = []richTextHtmlTag{ {name: HtmlParagraph} }
	case RichTextNodeHeading1:
		tags = []richTextHtmlTag{ {name: HtmlHeading1} }
	case RichTextNodeHeading2:
		tags = []richTextHtmlTag{ {name: HtmlHeading2} }
	case RichTextNodeHeading3:
		tags = []richTextHtmlTag{ {name: HtmlHeading3} }
	case RichTextNodeHeading4:
		tags = []richTextHtmlTag{ {name: HtmlHeading4} }
	case RichTextNodeHeading5:
		tags = []richTextHtmlTag{ {name: HtmlHeading5} }
	case RichTextNodeHeading6:
		tags = []richTextHtmlTag{ {name: HtmlHeading6} }
	case RichTextNodeOrderedList:
		tags = []richTextHtmlTag{ {name: HtmlOrderedList} }
	case RichTextNodeUnorderedList:
		tags = []richTextHtmlTag{ {name: HtmlUnorderedList} }
	case RichTextNodeListItem:
		tags = []richTextHtmlTag{ {name: HtmlListItem} }
	case RichTextNodeHR:
		tags = []richTextHtmlTag{ {name: HtmlHorizontalRule} }
	case RichTextNodeBlockquote:
		tags = []richTextHtmlTag{ {name: HtmlBlockquote} }
	case RichTextNodeText:
		tags = []richTextHtmlTag{}
	case RichTextNodeHyperlink:
		uri, _ := n.Data["uri"]
		attrs := map[string]string{}
		switch uri.(type) {
		case string:
			uriString := uri.(string)
			if uriString != "" {
				resolvedAttrs, errResolveAttrs := linkResolver(uriString)
				if errResolveAttrs != nil {
					err = errResolveAttrs
					return
				}
				attrs = resolvedAttrs
			}
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlAnchor, attrs: attrs}}
	case RichTextNodeEntryHyperlink:
		target, _ := n.Data["target"]
		attrs := map[string]string{}
		switch target.(type) {
		case map[string]interface{}:
			targetSys, ok := target.(map[string]interface{})["sys"]
			if ok {
				entryID := targetSys.(map[string]interface{})["id"].(string)
				resolvedAttrs, errResolveAttrs := entryLinkResolver(entryID, locale)
				if errResolveAttrs != nil {
					err = errResolveAttrs
					return
				}
				attrs = resolvedAttrs
			}
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlAnchor, attrs: attrs}}
	case RichTextNodeEmbeddedAsset:
		if imageResolver == nil {
			return errors.New("Can't resolve image asset URL")
		}
		dataObj := RichTextData{}
		byt, err := json.Marshal(n.Data)
		if err != nil {
			return err
		}
		err = json.Unmarshal(byt, &dataObj)
		if dataObj.Target == nil {
			return errors.New("Data target is empty")
		}
		attrs, customHTML, err := imageResolver(dataObj.Target.Sys.ID, locale)
		if err != nil {
			return err
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlImage, attrs: attrs, customHTML: customHTML}}
	case RichTextNodeEmbeddedEntry:
		dataObj := RichTextData{}
		byt, errMarshal := json.Marshal(n.Data)
		if errMarshal != nil {
			return errMarshal
		}
		errUnmarshal := json.Unmarshal(byt, &dataObj)
		if errUnmarshal != nil {
			return errUnmarshal
		}
		if dataObj.Target == nil {
			return errors.New("Data target is empty")
		}
		rawHTML, errResolve := embeddedEntryResolver(dataObj.Target.Sys.ID, locale)
		if errResolve != nil {
			return errResolve
		}
		w.Write([]byte(rawHTML))
		return
	default:
	}
	for _, m := range n.Marks {
		markTag := ""
		switch m.Type {
		case RichTextMarkBold:
			markTag = HtmlBold
		case RichTextMarkItalic:
			markTag = HtmlItalic
		case RichTextMarkUnderline:
			markTag = HtmlUnderline
		case RichTextMarkCode:
			markTag = HtmlCode
		case RichTextNodeBlockquote:
			markTag = HtmlBlockquote
		}
		if markTag != "" {
			tags = append(tags, richTextHtmlTag{name: markTag})
		}
	}

	tags.richTextHtmlTagsOpen(w)
	cleanString := strings.Replace(html.EscapeString(n.Value), "\n", "<br/>", -1)
	cleanString = strings.ReplaceAll(cleanString, "\u00a0", " ")
	w.Write([]byte(cleanString))
	for _, subNode := range n.Content {
		errSubNode := subNode.richTextRenderHTML(w, linkResolver, entryLinkResolver, imageResolver, embeddedEntryResolver, locale)
		if errSubNode != nil {
			err = errSubNode
			return
		}
	}
	tags.richTextHtmlTagsClose(w)
	return
}

func stringSliceContains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func updateCacheForContentType(ctx context.Context, results chan ContentTypeResult, cc *ContentfulClient, tempCache *ContentfulCache, contentType string) error {
	if ctx.Err() != nil {
		return ctx.Err()
	}
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		all{{ firstCap $contentType.Sys.ID }}, err := cc.cacheAll{{ firstCap $contentType.Sys.ID }}(ctx, results)
		if err != nil {
			return err
		}
		tempCache.entryMaps.{{ $contentType.Sys.ID }} = all{{ firstCap $contentType.Sys.ID }}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType":"{{ $contentType.Sys.ID }}", "method": "updateCacheForContentType", "size":len(all{{ firstCap $contentType.Sys.ID }})}, LogInfo, InfoCachedAllEntries)
		}
	{{ end }}
	case assetWorkerType:
		allAssets, err := cc.getAllAssets(false)
		if err != nil {
			return err
		}
		tempCache.assets = allAssets
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "asset", "method": "updateCacheForContentType", "size": len(allAssets)}, LogInfo, InfoCachedAllAssets)
		}
	}
	return nil
}

func updateCacheForContentTypeAndEntity(ctx context.Context, cc *ContentfulClient, sysType string, contentType string, entityID string) error {
	if ctx.Err() != nil {
		return ctx.Err()
	}
	switch contentType {
	case assetWorkerType:
		err := cc.cacheGcAssetByID(ctx, entityID)
		if err != nil {
			return err
		}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "Asset", "method": "updateCacheForContentTypeAndEntity", "entityID": entityID}, LogInfo, InfoUpdatedEntityCache)
		}
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		err := cc.cache{{ firstCap $contentType.Sys.ID }}ByID(ctx, entityID)
		if err != nil {
			return err
		}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "{{ $contentType.Sys.ID }}", "method": "updateCacheForContentTypeAndEntity", "entityID": entityID}, LogInfo, InfoUpdatedEntityCache)
		}
	{{ end }}
	}
	return nil
}

func commonGetParents(cc *ContentfulClient, id string, contentType []string) (parents []EntryReference, err error) {
	parents = []EntryReference{}
	if cc.Cache != nil {
		if len(contentType) != 0 {
			for _, parent := range cc.Cache.parentMap[id] {
				if parent.ContentType == contentType[0] {
					parents = append(parents, parent)
				}
			}
			return parents, nil
		}
		return cc.Cache.parentMap[id], nil
	}
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.Equal("links_to_entry", id).Locale("*")
	_, err = col.GetAll()
	if err != nil {
		return nil, errors.New("GetParents: " + err.Error())
	}
	for _, item := range col.Items {
    		var entry contentful.Entry
    		byteArray, err := json.Marshal(item)
    		if err != nil {
    			return nil, err
    		}
    		err = json.Unmarshal(byteArray, &entry)
    		if err != nil {
    			return nil, err
    		}
    		if len(contentType) == 1 && contentType[0] != entry.Sys.ContentType.Sys.ID {
    			continue
    		}
    		switch entry.Sys.ContentType.Sys.ID { {{ range $index , $contentType := $contentTypes }}
	        case ContentType{{ firstCap $contentType.Sys.ID }}:
		    	var parentVO Cf{{ firstCap $contentType.Sys.ID }}
                byteArray, _ := json.Marshal(item)
                err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&parentVO)
                if err != nil {
                    return nil, errors.New("GetParents: " + err.Error())
                }
                parentVO.CC = cc
                parents = append(
                    parents, EntryReference{
                        ContentType: entry.Sys.ContentType.Sys.ID,
                        ID:          entry.Sys.ID,
                        VO:          &parentVO,
                    })
            {{ end }} }
	}
	return parents, nil
}
