// Package {{ .PackageName }} - DO NOT EDIT THIS FILE: Auto-generated code by https://github.com/foomo/contentful-erm
{{ $cfg := . }}{{ $locales := .Locales }}{{ $contentTypes := .ContentTypes }}package {{ .PackageName }}

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"
	"github.com/foomo/contentful"
)

{{ range $index , $locale := $locales }}const spaceLocale{{ onlyLetters $locale.Name }} string = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale string = spaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var spaceLocales []string = []string{ {{ range $index , $locale := $locales }}spaceLocale{{ onlyLetters $locale.Name }}, {{ end }} }
var localeFallback = map[string]string{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} spaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}spaceLocale{{ onlyLetters $localeSearch.Name }}{{end}}{{end}}, {{ end }}{{ end }}}

type ContentfulKeys struct {
	CDAKey  string
	CPAKey  string
	CMAKey  string
}
type ContentfulClient struct {
	SpaceID string
	CDA     *contentful.Contentful
	CPA     *contentful.Contentful
	CMA     *contentful.Contentful
	Debug   bool
}

func NewContentfulClient(spaceID string, ck *ContentfulKeys, debug bool) (*ContentfulClient, error) {
	cc := &ContentfulClient{}
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	cc.SpaceID = spaceID
	if ck == nil {
		return nil, errors.New("NewContentfulClient: Please provide at least one API key")
	}
	if ck.CDAKey == "" && ck.CPAKey == "" && ck.CMAKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide at least one API Key")
	}
	if ck.CDAKey != "" {
		cc.CDA = contentful.NewCDA(ck.CDAKey)
		cc.CDA.Debug = debug
	}
	if ck.CPAKey != "" {
		cc.CPA = contentful.NewCPA(ck.CPAKey)
		cc.CPA.Debug = debug
	}
	if ck.CMAKey != "" {
		cc.CMA = contentful.NewCMA(ck.CMAKey)
		cc.CMA.Debug = debug
	}
	return cc, nil
}


func NewAsset(id string, uploadUrl string, imageFileType string, title string, locale ...string) *ContentfulAsset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	asset := &ContentfulAsset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				loc: &contentful.File{
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				loc: title,
			},
		},
	}
	return asset
}

func (asset *ContentfulAsset) UpsertAndProcess(cc *ContentfulClient) error {
	cAsset := &contentful.Asset{Sys: asset.Sys, Fields: asset.Fields}
	err := cc.CMA.Assets.Upsert(cc.SpaceID, cAsset)
	if err != nil {
		return err
	}
	err = cc.CMA.Assets.Process(cc.SpaceID, cAsset)
	if err != nil {
		return err
	}
	return nil
}

func (asset ContentfulAsset) ToAssetReference() (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = "Link"
	refSys.Sys.LinkType = "Asset"
	return
}

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}
{{ range $index , $contentType := $contentTypes }}

// ---{{ firstCap $contentType.Sys.ID }} methods---

func NewCf{{ firstCap $contentType.Sys.ID }}() (cf{{ firstCap $contentType.Sys.ID }} *Cf{{ firstCap $contentType.Sys.ID }}) {
	cf{{ firstCap $contentType.Sys.ID }} = &Cf{{ firstCap $contentType.Sys.ID }}{}
	{{ range $fieldIndex, $field := $contentType.Fields }}cf{{ firstCap $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }} = make(map[string]{{ mapFieldType $contentType.Sys.ID $field }})
	{{ end }}
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.ID = "{{ $contentType.Sys.ID }}"
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.Type = "Link"
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.LinkType = "ContentType"
	return
}

func (cc *ContentfulClient) GetAll{{ firstCap $contentType.Sys.ID }}() (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	return cc.GetFiltered{{ firstCap $contentType.Sys.ID }}(nil)
}

func (cc *ContentfulClient) GetFiltered{{ firstCap $contentType.Sys.ID }}(query *contentful.Query) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CDA == nil {
		return nil, errors.New("getFiltered{{ firstCap $contentType.Sys.ID }}: No CDA client available")
	}
	col := cc.CDA.Entries.List(cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(10)
	col.GetAll()
	return ColToCf{{ firstCap $contentType.Sys.ID }}(col)
}

func (cc *ContentfulClient) Get{{ firstCap $contentType.Sys.ID }}ByID(id string) (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CDA == nil {
		return nil, errors.New("get{{ firstCap $contentType.Sys.ID }}ByID: No CDA client available")
	}
	col := cc.CDA.Entries.List(cc.SpaceID)
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Equal("sys.id",id)
	col.GetAll()
	vos, err := ColToCf{{ firstCap $contentType.Sys.ID }}(col)
	if err != nil {
		return nil, errors.New("get{{ firstCap $contentType.Sys.ID }}ByID: Error converting to VO")
	}
	vo = vos[0]
	return
}

func (cc *ContentfulClient) PreviewAll{{ firstCap $contentType.Sys.ID }}() (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	return cc.PreviewFiltered{{ firstCap $contentType.Sys.ID }}(nil)
}

func (cc *ContentfulClient) PreviewFiltered{{ firstCap $contentType.Sys.ID }}(query *contentful.Query) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CPA == nil {
		return nil, errors.New("PreviewFiltered{{ firstCap $contentType.Sys.ID }}: No CPA client available")
	}
	col := cc.CPA.Entries.List(cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(10)
	col.GetAll()
	return ColToCf{{ firstCap $contentType.Sys.ID }}(col)
}

func (cc *ContentfulClient) Preview{{ firstCap $contentType.Sys.ID }}ByID(id string) (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CPA == nil {
		return nil, errors.New("Preview{{ firstCap $contentType.Sys.ID }}ByID: No CDA client available")
	}
	col := cc.CPA.Entries.List(cc.SpaceID)
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Equal("sys.id",id)
	col.GetAll()
	vos, err := ColToCf{{ firstCap $contentType.Sys.ID }}(col)
	if err != nil {
		return nil, errors.New("Preview{{ firstCap $contentType.Sys.ID }}ByID: Error converting to VO")
	}
	vo = vos[0]
	return
}

func ColToCf{{ firstCap $contentType.Sys.ID }}(col *contentful.Collection) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	for _, item := range col.Items {
		var vo Cf{{ firstCap $contentType.Sys.ID }}
		byteArray, _ := json.Marshal(item)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			break
		}
		vo.Col = col
		vos = append(vos, &vo)
	}
	return vos, err
}

func (ref ContentfulReferencedEntry) ToCf{{ firstCap $contentType.Sys.ID }}() (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
		byteArray, _ := json.Marshal(ref.Entry)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			return nil, err
		}
		vo.Col = ref.Col
	return vo, nil
}

// {{ firstCap $contentType.Sys.ID }} Field getters
{{ range $fieldIndex, $field := $contentType.Fields }}
{{ if fieldIsBasic $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} {{ mapFieldType $contentType.Sys.ID $field }}, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback locale available")
			return
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback value available")
			return
		}
	}
	{{ $field.ID }} = vo.Fields.{{ firstCap $field.ID }}[loc]
	return
}{{ end }}
{{ if fieldIsMultipleReference $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} []ContentfulReferencedEntry, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback locale available")
			return
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback value available")
			return
		}
	}
	for _, eachLocalized{{ firstCap $field.ID }} := range vo.Fields.{{ firstCap $field.ID }}[loc] {
		includeEntryMap := vo.Col.ToIncludesEntryMap()
		var referencedEntry *contentful.Entry
		if ref, ok := includeEntryMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID]; ok {
			referencedEntry = ref
		} else {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: referenced entry not found in includes")
			return
		}

		{{ $field.ID }} = append({{ $field.ID }}, ContentfulReferencedEntry{
			Entry: referencedEntry,
			Col:   vo.Col,
		})
	}
	return
}{{ end }}
{{ if fieldIsReference $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} ContentfulReferencedEntry, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback locale available")
			return
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback value available")
			return
		}
	}
	localized{{ firstCap $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[loc]
	includesEntryMap := vo.Col.ToIncludesEntryMap()
	if referencedEntry, ok := includesEntryMap[localized{{ firstCap $field.ID }}.Sys.ID]; ok {
		{{ $field.ID }}.Entry = referencedEntry
		{{ $field.ID }}.Col = vo.Col
		return
	} 
	err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: referenced entry not found in includes")
	return
}{{ end }}
{{ if fieldIsMultipleAsset $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} []ContentfulReferencedAsset, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback locale available")
			return
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback value available")
			return
		}
	}
	for _, eachLocalized{{ firstCap $field.ID }} := range vo.Fields.{{ firstCap $field.ID }}[loc] {
		includeAssetMap := vo.Col.ToIncludesAssetMap()
		var referencedAsset *contentful.Asset
		if ref, ok := includeAssetMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID]; ok {
			referencedAsset = ref
		} else {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: referenced entry not found in includes")
			return
		}

		{{ $field.ID }} = append({{ $field.ID }}, ContentfulReferencedAsset{
			Asset: referencedAsset,
			Col:   vo.Col,
		})
	}
	return
}{{ end }}
{{ if fieldIsAsset $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} ContentfulReferencedAsset, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback locale available")
			return
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; !ok {
			err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: not found, no fallback value available")
			return
		}
	}
	localized{{ firstCap $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[loc]
	includesAssetMap := vo.Col.ToIncludesAssetMap()
	if referencedAsset, ok := includesAssetMap[localized{{ firstCap $field.ID }}.Sys.ID]; ok {
		{{ $field.ID }}.Asset = referencedAsset
		{{ $field.ID }}.Col = vo.Col
		return
	} 
	err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: referenced asset not found in includes")
	return
}{{ end }}
{{ end }}

// {{ firstCap $contentType.Sys.ID }} Field setters
{{ range $fieldIndex, $field := $contentType.Fields }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Set{{ firstCap $field.ID }}({{ $field.ID }} {{ mapFieldType $contentType.Sys.ID $field }}, locale ...string) (err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	vo.Fields.{{ firstCap $field.ID }}[loc] = {{ $field.ID }}
	return
}
{{ end }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Save(cc *ContentfulClient) (err error) {
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} save: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} save: Can't unmarshal JSON into CF entry")
	}

	err = cc.CMA.Entries.Upsert(cc.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} save: upsert operation failed: %s", err)
	}
	tmp, errMarshal = json.Marshal(cfEntry)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} save: Can't marshal JSON back from CF entry")
	}
	errUnmarshal = json.Unmarshal(tmp, &vo)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} save: Can't unmarshal JSON back into VO")
	}
	err = cc.CMA.Entries.Publish(cc.SpaceID, cfEntry)
	if err != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} save: publish operation failed")
	}
	return
}

func (vo *Cf{{ firstCap $contentType.Sys.ID }}) ToReference() (refSys ContentTypeSys) {
	refSys.Sys.ID = vo.Sys.ID
	refSys.Sys.Type = "Link"
	refSys.Sys.LinkType = "Entry"
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) ToReferenceArray() (refSysArray []ContentTypeSys) {
	refSys := ContentTypeSys{}
	refSys.Sys.ID = vo.Sys.ID
	refSys.Sys.Type = "Link"
	refSys.Sys.LinkType = "Entry"
	refSysArray = append(refSysArray,refSys)
	return
}


{{ end }}