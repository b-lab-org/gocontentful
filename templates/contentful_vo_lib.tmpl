// Package {{ .PackageName }} - DO NOT EDIT THIS FILE: Auto-generated code by https://github.com/foomo/contentful-erm
{{ $cfg := . }}{{ $locales := .Locales }}{{ $contentTypes := .ContentTypes }}package {{ .PackageName }}

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"
	"github.com/foomo/contentful"
)

type Locale string

{{ range $index , $locale := $locales }}const spaceLocale{{ onlyLetters $locale.Name }} Locale = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale Locale = spaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var localeFallback = map[Locale]Locale{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} spaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}spaceLocale{{ onlyLetters $localeSearch.Name }}{{end}}{{end}}, {{else}}spaceLocale{{ onlyLetters $locale.Name }}: "", {{ end }}{{ end }}}

var (
	ErrLocaleUnsupported = errors.New("Locale not supported by this space")
	ErrNotSet            = errors.New("Field value not set")
	ErrNotSetNoFallback  = errors.New("Field value not set and no fallback locale available")
	ErrRefNotIncludes    = errors.New("Referenced entry not found in includes")
)

type ContentfulKeys struct {
	CDAKey  string
	CPAKey  string
	CMAKey  string
}
type ContentfulClient struct {
	SpaceID string
	CDA     *contentful.Contentful
	CPA     *contentful.Contentful
	CMA     *contentful.Contentful
	Debug   bool
}

func NewContentfulClient(spaceID string, ck *ContentfulKeys, debug bool) (*ContentfulClient, error) {
	cc := &ContentfulClient{}
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	cc.SpaceID = spaceID
	if ck == nil {
		return nil, errors.New("NewContentfulClient: Please provide at least one API key")
	}
	if ck.CDAKey == "" && ck.CPAKey == "" && ck.CMAKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide at least one API Key")
	}
	if ck.CDAKey != "" {
		cc.CDA = contentful.NewCDA(ck.CDAKey)
		cc.CDA.Debug = debug
	}
	if ck.CPAKey != "" {
		cc.CPA = contentful.NewCPA(ck.CPAKey)
		cc.CPA.Debug = debug
	}
	if ck.CMAKey != "" {
		cc.CMA = contentful.NewCMA(ck.CMAKey)
		cc.CMA.Debug = debug
	}
	return cc, nil
}

// Asset utils
func NewAssetFromURL(id string, uploadUrl string, imageFileType string, title string, locale ...Locale) *contentful.Asset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc Locale
	if len(locale) != 0 {
		loc = locale[0]
		if localeFallback[loc]!="" {
			return nil
		}
	} else {
		loc = defaultLocale
	}
	asset := &contentful.Asset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				string(loc): &contentful.File{
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				string(loc): title,
			},
		},
	}
	return asset
}

func ToAssetReference(asset *contentful.Asset) (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeAsset
	return
}

// RichText utils

func HtmlToRichText(htmlSrc string) *RichTextNode {
	htmlClean := strings.TrimSpace(htmlSrc)
	htmlClean = strings.ReplaceAll(htmlClean, `&nbsp;`, ` `)
	htmlClean = strings.ReplaceAll(htmlClean, "\t", "")
	htmlClean = regexp.MustCompile(`[\s]{2,}`).ReplaceAllString(htmlClean, " ")
	re := regexp.MustCompile(`>([^\n])`)
	htmlClean = re.ReplaceAllString(htmlClean, fmt.Sprintf(">\n"+`$1`))
	re = regexp.MustCompile(`(.{1})<`)
	htmlClean = re.ReplaceAllString(htmlClean, `$1`+fmt.Sprintf("\n<"))
	htmlLines := strings.Split(htmlClean, "\n")
	rtnd := &RichTextNode{
		NodeType: RichTextNodeDocument,
	}
	rtnd.Content, _ = htmlLinesToRichTextNode(htmlLines, 0, "", nil)
	if len(rtnd.Content) == 1 && rtnd.Content[0].(RichTextNodeTextNode).NodeType == RichTextNodeText {
		basicRich := &RichTextNode{
			NodeType: RichTextNodeDocument,
		}
		par := RichTextNode{
			NodeType: RichTextNodeParagraph,
		}
		text := RichTextNodeTextNode{
			NodeType: RichTextNodeText,
			Value:    rtnd.Content[0].(RichTextNodeTextNode).Value,
			Marks:    []RichTextMark{},
		}
		par.Content = append(par.Content, text)
		basicRich.Content = append(basicRich.Content, par)
		return basicRich
	}
	return rtnd
}

func getMark(mark string) string {
	switch mark {
	case HtmlItalic, HtmlEm:
		return RichTextMarkItalic
	case HtmlBold, HtmlStrong:
		return RichTextMarkBold
	}
	return ""
}

func getAttribute(htmlLine string, attribute string) string {
	re := regexp.MustCompile(` href=["']([^"']+)["']`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func htmlLinesToRichTextNode(htmlLines []string, start int, pendingTag string, marks []string) ([]interface{}, int) {
	nodeSlice := make([]interface{}, 0)
	for i := start; i < len(htmlLines); i++ {
		htmlLine := htmlLines[i]
		if isClosingPending(htmlLine, pendingTag) {
			return nodeSlice, i
		}
		currentNode := RichTextNode{}
		if isTag(htmlLine) {
			tt := tagType(htmlLine)
			switch tt {
			case HtmlParagraph, HtmlHeading1, HtmlHeading2, HtmlHeading3, HtmlHeading4, HtmlHeading5, HtmlHeading6, HtmlUnorderedList, HtmlOrderedList:
				currentNode.NodeType = mapTagRichTextNodeType(tt)
				var nextLine int
				currentNode.Content, nextLine = htmlLinesToRichTextNode(htmlLines, i+1, tt, marks)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1
				}
				i = nextLine
			case HtmlBlockquote, HtmlListItem:
				currentNode.NodeType = mapTagRichTextNodeType(tt)
				currentNode.Content = make([]interface{}, 0)
				innerContent, nextLine := htmlLinesToRichTextNode(htmlLines, i+1, tt, marks)
				currentNode.Content = append(currentNode.Content, RichTextNode{
					NodeType: RichTextNodeParagraph,
					Content:  innerContent,
				})
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1
				}
				i = nextLine
			case HtmlAnchor:
				currentNode.NodeType = RichTextNodeHyperlink
				var nextLine int
				currentNode.Data = RichTextData{URI: getAttribute(htmlLine, HtmlAttributeHref)}
				currentNode.Content, nextLine = htmlLinesToRichTextNode(htmlLines, i+1, tt, marks)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1
				}
				i = nextLine
			case HtmlHorizontalRule:
				currentNode.NodeType = RichTextNodeHR
				currentNode.Content = make([]interface{}, 0)
				nodeSlice = append(nodeSlice, currentNode)
			case HtmlItalic, HtmlEm, HtmlBold, HtmlStrong:
				marks = append(marks, tt)
			case HtmlBreak:
				if nodeSlice[len(nodeSlice)-1].(RichTextNodeTextNode).NodeType == RichTextNodeText {
					target := nodeSlice[len(nodeSlice)-1].(RichTextNodeTextNode)
					target.Value += "\n"
					nodeSlice[len(nodeSlice)-1] = target
				}
			}
			continue //unsupported tags will be ignored but content is preserved
		}
		if isClosingTag(htmlLine) {
			continue //closing tags that are not pending equal to unknown
		}
		if htmlLine == " " {
			continue
		}
		currentNodeTextNode := RichTextNodeTextNode{}
		currentNodeTextNode.NodeType = RichTextNodeText
		currentNodeTextNode.Marks = []RichTextMark{}
		currentNodeTextNode.Value = htmlLine
		for _, mark := range marks {
			currentNodeTextNode.Marks = append(currentNodeTextNode.Marks, RichTextMark{
				Type: getMark(mark),
			})
		}
		marks = nil
		nodeSlice = append(nodeSlice, currentNodeTextNode)
	}
	return nodeSlice, -1
}

func isClosingPending(htmlLine, tag string) bool {
	return regexp.MustCompile(`</` + strings.ToLower(tag) + `.+$`).MatchString(strings.ToLower(htmlLine))
}

func isClosingTag(htmlLine string) bool {
	return regexp.MustCompile(`</[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func isTag(htmlLine string) bool {
	return regexp.MustCompile(`<[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func mapTagRichTextNodeType(tag string) string {
	switch tag {
	case HtmlParagraph:
		return RichTextNodeParagraph
	case HtmlAnchor:
		return RichTextNodeHyperlink
	case HtmlHeading1:
		return RichTextNodeHeading1
	case HtmlHeading2:
		return RichTextNodeHeading2
	case HtmlHeading3:
		return RichTextNodeHeading3
	case HtmlHeading4:
		return RichTextNodeHeading4
	case HtmlHeading5:
		return RichTextNodeHeading5
	case HtmlHeading6:
		return RichTextNodeHeading6
	case HtmlBlockquote:
		return RichTextNodeBlockquote
	case HtmlUnorderedList:
		return RichTextNodeUnorderedList
	case HtmlOrderedList:
		return RichTextNodeOrderedList
	case HtmlListItem:
		return RichTextNodeListItem
	}
	return ""
}

func tagType(htmlLine string) string {
	re := regexp.MustCompile(`^<([a-zA-Z0-9]+)[\s]*>*`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

// Other utils

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}
{{ range $index , $contentType := $contentTypes }}

// ---{{ firstCap $contentType.Sys.ID }} methods---

func NewCf{{ firstCap $contentType.Sys.ID }}() (cf{{ firstCap $contentType.Sys.ID }} *Cf{{ firstCap $contentType.Sys.ID }}) {
	cf{{ firstCap $contentType.Sys.ID }} = &Cf{{ firstCap $contentType.Sys.ID }}{}
	{{ range $fieldIndex, $field := $contentType.Fields }}cf{{ firstCap $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }} = map[string]{{ mapFieldType $contentType.Sys.ID $field }}{}
	{{ end }}
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.ID = "{{ $contentType.Sys.ID }}"
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.Type = FieldTypeLink
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.LinkType = "ContentType"
	return
}

func (cc *ContentfulClient) GetAll{{ firstCap $contentType.Sys.ID }}() (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	return cc.GetFiltered{{ firstCap $contentType.Sys.ID }}(nil)
}

func (cc *ContentfulClient) GetFiltered{{ firstCap $contentType.Sys.ID }}(query *contentful.Query) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CDA == nil {
		return nil, errors.New("getFiltered{{ firstCap $contentType.Sys.ID }}: No CDA client available")
	}
	col := cc.CDA.Entries.List(cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(10)
	col.GetAll()
	return ColToCf{{ firstCap $contentType.Sys.ID }}(col)
}

func (cc *ContentfulClient) Get{{ firstCap $contentType.Sys.ID }}ByID(id string) (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CDA == nil {
		return nil, errors.New("Get{{ firstCap $contentType.Sys.ID }}ByID: No CDA client available")
	}
	col := cc.CDA.Entries.List(cc.SpaceID)
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Equal("sys.id",id)
	col.GetAll()
	if len(col.Items) == 0 {
		return nil, fmt.Errorf("Get{{ firstCap $contentType.Sys.ID }}ByID: %s Not found", id)
	}
	vos, err := ColToCf{{ firstCap $contentType.Sys.ID }}(col)
	if err != nil {
		return nil, fmt.Errorf("Get{{ firstCap $contentType.Sys.ID }}ByID: Error converting %s to VO: " + err.Error(), id)
	}
	vo = vos[0]
	return
}

func (cc *ContentfulClient) PreviewAll{{ firstCap $contentType.Sys.ID }}() (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	return cc.PreviewFiltered{{ firstCap $contentType.Sys.ID }}(nil)
}

func (cc *ContentfulClient) PreviewFiltered{{ firstCap $contentType.Sys.ID }}(query *contentful.Query) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CPA == nil {
		return nil, errors.New("PreviewFiltered{{ firstCap $contentType.Sys.ID }}: No CPA client available")
	}
	col := cc.CPA.Entries.List(cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(10)
	col.GetAll()
	return ColToCf{{ firstCap $contentType.Sys.ID }}(col)
}

func (cc *ContentfulClient) Preview{{ firstCap $contentType.Sys.ID }}ByID(id string) (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CPA == nil {
		return nil, errors.New("Preview{{ firstCap $contentType.Sys.ID }}ByID: No CPA client available")
	}
	col := cc.CPA.Entries.List(cc.SpaceID)
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Equal("sys.id",id)
	col.GetAll()
	if len(col.Items) == 0 {
		return nil, fmt.Errorf("Preview{{ firstCap $contentType.Sys.ID }}ByID: %s Not found", id)
	}
	vos, err := ColToCf{{ firstCap $contentType.Sys.ID }}(col)
	if err != nil {
		return nil, fmt.Errorf("Preview{{ firstCap $contentType.Sys.ID }}ByID: Error converting %s to VO: " + err.Error(), id)
	}
	vo = vos[0]
	return
}

func (cc *ContentfulClient) ManageAll{{ firstCap $contentType.Sys.ID }}() (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	return cc.ManageFiltered{{ firstCap $contentType.Sys.ID }}(nil)
}

func (cc *ContentfulClient) ManageFiltered{{ firstCap $contentType.Sys.ID }}(query *contentful.Query) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CMA == nil {
		return nil, errors.New("ManageFiltered{{ firstCap $contentType.Sys.ID }}: No CMA client available")
	}
	col := cc.CMA.Entries.List(cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(10)
	col.GetAll()
	return ColToCf{{ firstCap $contentType.Sys.ID }}(col)
}

func (cc *ContentfulClient) Manage{{ firstCap $contentType.Sys.ID }}ByID(id string) (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CMA == nil {
		return nil, errors.New("Manage{{ firstCap $contentType.Sys.ID }}ByID: No CMA client available")
	}
	col := cc.CMA.Entries.List(cc.SpaceID)
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Equal("sys.id",id)
	col.GetAll()
	if len(col.Items) == 0 {
		return nil, fmt.Errorf("Manage{{ firstCap $contentType.Sys.ID }}ByID: %s Not found", id)
	}
	vos, err := ColToCf{{ firstCap $contentType.Sys.ID }}(col)
	if err != nil {
		return nil, fmt.Errorf("Manage{{ firstCap $contentType.Sys.ID }}ByID: Error converting %s to VO: " + err.Error(), id)
	}
	vo = vos[0]
	return
}

func ColToCf{{ firstCap $contentType.Sys.ID }}(col *contentful.Collection) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	for _, item := range col.Items {
		var vo Cf{{ firstCap $contentType.Sys.ID }}
		byteArray, _ := json.Marshal(item)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			break
		}
		vo.Col = col
		vos = append(vos, &vo)
	}
	return vos, err
}

func (ref ContentfulReferencedEntry) ToCf{{ firstCap $contentType.Sys.ID }}() (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
		byteArray, _ := json.Marshal(ref.Entry)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			return nil, err
		}
		vo.Col = ref.Col
	return vo, nil
}

// {{ firstCap $contentType.Sys.ID }} Field getters
{{ range $fieldIndex, $field := $contentType.Fields }}
{{ if fieldIsBasic $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) ({{ mapFieldType $contentType.Sys.ID $field }}, error) {
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}, ErrLocaleUnsupported
		}
	} 
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}, ErrNotSet
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}, ErrNotSetNoFallback
		}
	}
	return vo.Fields.{{ firstCap $field.ID }}[string(loc)], nil
}{{ end }}{{ if fieldIsComplex $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) (*{{ mapFieldType $contentType.Sys.ID $field }}, error) {
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}, ErrLocaleUnsupported
		}
	} 
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}, ErrNotSet
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}, ErrNotSetNoFallback
		}
	}
	{{ $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[string(loc)]
	return &{{ $field.ID }}, nil
}{{ end }}{{ if fieldIsMultipleReference $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) ([]*ContentfulReferencedEntry, error) {
	{{ $field.ID }} := []*ContentfulReferencedEntry{}
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrLocaleUnsupported
		}
	} 
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrNotSet
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			return nil, ErrNotSetNoFallback
		}
	}
	for _, eachLocalized{{ firstCap $field.ID }} := range vo.Fields.{{ firstCap $field.ID }}[string(loc)] {
		includeEntryMap := vo.Col.ToIncludesEntryMap()
		if _, ok := includeEntryMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID]; !ok {
			return nil, ErrRefNotIncludes
		}
		{{ $field.ID }} = append({{ $field.ID }}, &ContentfulReferencedEntry{
			Entry: includeEntryMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID],
			Col:   vo.Col,
		})
	}
	return {{ $field.ID }}, nil 
}{{ end }}{{ if fieldIsReference $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) (*ContentfulReferencedEntry, error) {
	{{ $field.ID }} := &ContentfulReferencedEntry{}
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrLocaleUnsupported
		}
	} 
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrNotSet
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			return nil, ErrNotSetNoFallback
		}
	}
	localized{{ firstCap $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[string(loc)]
	includesEntryMap := vo.Col.ToIncludesEntryMap()
	if _, ok := includesEntryMap[localized{{ firstCap $field.ID }}.Sys.ID]; !ok {
		return nil, ErrRefNotIncludes
	} 
	{{ $field.ID }}.Entry = includesEntryMap[localized{{ firstCap $field.ID }}.Sys.ID]
	{{ $field.ID }}.Col = vo.Col
	return {{ $field.ID }}, nil
}{{ end }}{{ if fieldIsMultipleAsset $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) ([]*contentful.AssetNoLocale, error) {
	{{ $field.ID }} := []*contentful.AssetNoLocale{}
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrLocaleUnsupported
		}
	} 
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrNotSet
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			return nil, ErrNotSetNoFallback
		}
	}
	for _, eachLocalized{{ firstCap $field.ID }} := range vo.Fields.{{ firstCap $field.ID }}[string(loc)] {
		includeAssetMap := vo.Col.ToIncludesLocalizedAssetMap()
		if _, ok := includeAssetMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID]; !ok {
			return nil, ErrRefNotIncludes
			
		}
		tempAsset := &contentful.AssetNoLocale{}
		tempAsset.Sys = includeAssetMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID].Sys
		tempAsset.Fields = &contentful.FileFieldsNoLocale{}
		tempAsset.Fields.Title = includeAssetMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID].Fields.Title[string(loc)]
		tempAsset.Fields.Description = includeAssetMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID].Fields.Description[string(loc)]
		tempAsset.Fields.File = includeAssetMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID].Fields.File[string(loc)]
		{{ $field.ID }} = append({{ $field.ID }}, tempAsset)
	}
	return {{ $field.ID }}, nil
}{{ end }}{{ if fieldIsAsset $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) (*contentful.AssetNoLocale, error) {
	{{ $field.ID }} := &contentful.AssetNoLocale{}
	{{ $field.ID }}.Fields = &contentful.FileFieldsNoLocale{}
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrLocaleUnsupported
		}
	} 
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			return nil, ErrNotSet
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			return nil, ErrNotSetNoFallback
		}
	}
	localized{{ firstCap $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[string(loc)]
	includesAssetMap := vo.Col.ToIncludesLocalizedAssetMap()
	if _, ok := includesAssetMap[localized{{ firstCap $field.ID }}.Sys.ID]; !ok {
		return nil, ErrRefNotIncludes
	}
	{{ $field.ID }}.Sys = includesAssetMap[localized{{ firstCap $field.ID }}.Sys.ID].Sys
	{{ $field.ID }}.Fields.Title = includesAssetMap[localized{{ firstCap $field.ID }}.Sys.ID].Fields.Title[string(loc)]
	{{ $field.ID }}.Fields.Description = includesAssetMap[localized{{ firstCap $field.ID }}.Sys.ID].Fields.Description[string(loc)]
	{{ $field.ID }}.Fields.File = includesAssetMap[localized{{ firstCap $field.ID }}.Sys.ID].Fields.File[string(loc)]
	return {{ $field.ID }}, nil
}{{ end }}{{ end }}

// {{ firstCap $contentType.Sys.ID }} Field setters
{{ range $fieldIndex, $field := $contentType.Fields }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Set{{ firstCap $field.ID }}({{ $field.ID }} {{ mapFieldType $contentType.Sys.ID $field }}, locale ...Locale) (err error) {
	loc := defaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	if vo.Fields.{{ firstCap $field.ID }} == nil {
		vo.Fields.{{ firstCap $field.ID }} = make(map[string]{{ mapFieldType $contentType.Sys.ID $field }})
	} 
	vo.Fields.{{ firstCap $field.ID }}[string(loc)] = {{ $field.ID }}
	return
}
{{ end }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) UpsertEntry(cc *ContentfulClient) (err error) {
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpsertEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpsertEntry: Can't unmarshal JSON into CF entry")
	}

	err = cc.CMA.Entries.Upsert(cc.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} UpsertEntry: Operation failed: %s", err)
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) PublishEntry(cc *ContentfulClient) (err error) {
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} PublishEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} PublishEntry: Can't unmarshal JSON into CF entry")
	}
	err = cc.CMA.Entries.Publish(cc.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} PublishEntry: publish operation failed: %s", err)
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) UpdateEntry(cc *ContentfulClient) (err error) {
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't unmarshal JSON into CF entry")
	}

	err = cc.CMA.Entries.Upsert(cc.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: upsert operation failed: %s", err)
	}
	tmp, errMarshal = json.Marshal(cfEntry)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't marshal JSON back from CF entry")
	}
	errUnmarshal = json.Unmarshal(tmp, &vo)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't unmarshal JSON back into VO")
	}
	err = cc.CMA.Entries.Publish(cc.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: publish operation failed: %s", err)
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) DeleteEntry(cc *ContentfulClient) (err error) {
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Can't unmarshal JSON into CF entry")
	}
	if cfEntry.Sys.PublishedCounter > 0 {
		errUnpublish := cc.CMA.Entries.Unpublish(cc.SpaceID, cfEntry)
		if errUnpublish != nil {
			return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Unpublish entry failed: %w", errUnpublish)
		}
	}
	errDelete := cc.CMA.Entries.Delete(cc.SpaceID, cfEntry.Sys.ID)
	if errDelete != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Delete entry failed: %w", errDelete)
	}
	return nil
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) ToReference() (refSys ContentTypeSys) {
	refSys.Sys.ID = vo.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeEntry
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) ToReferenceArray() (refSysArray []ContentTypeSys) {
	refSys := ContentTypeSys{}
	refSys.Sys.ID = vo.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeEntry
	refSysArray = append(refSysArray,refSys)
	return
}


{{ end }}