// DO NOT EDIT THIS FILE: Auto-generated code by https://github.com/foomo/contentful-erm
{{ $cfg := . }}{{ $locales := .Locales }}{{ $contentTypes := .ContentTypes }}
package {{ .PackageName }}

import (
	"bytes"
	"encoding/json"
	"errors"

	"github.com/foomo/contentful"
)

{{ range $index , $locale := $locales }}const spaceLocale{{ onlyLetters $locale.Name }} string = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale string = spaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var spaceLocales []string = []string{ {{ range $index , $locale := $locales }}spaceLocale{{ onlyLetters $locale.Name }}, {{ end }} }

type contentfulClient struct {
	SpaceID string
	CDAKey  string
	CPAKey  string
	CMAKey  string
	CDA     *contentful.Contentful
	CPA     *contentful.Contentful
	CMA     *contentful.Contentful
	Debug   bool
}

func getContentfulClient(cc *contentfulClient) (ccOut *contentfulClient, err error) {
	if cc.SpaceID == "" {
		return nil, errors.New("GetContentfulClient: SpaceID cannot be empty")
	}
	if cc.CDAKey == "" && cc.CPAKey == "" && cc.CMAKey == "" {
		return nil, errors.New("GetContentfulClient: You must provide at least one API Key")
	}
	if cc.CDAKey != "" {
		cc.CDA = contentful.NewCDA(cc.CDAKey)
		cc.CDA.Debug = cc.Debug == true
	}
	if cc.CPAKey != "" {
		cc.CPA = contentful.NewCPA(cc.CDAKey)
		cc.CPA.Debug = cc.Debug == true
	}
	if cc.CMAKey != "" {
		cc.CMA = contentful.NewCMA(cc.CDAKey)
		cc.CPA.Debug = cc.Debug == true
	}
	return cc, nil
}
{{ range $index , $contentType := $contentTypes }}
// ---{{ firstCap $contentType.Sys.ID }} methods---

func newCf{{ firstCap $contentType.Sys.ID }}() (cf{{ firstCap $contentType.Sys.ID }} *Cf{{ firstCap $contentType.Sys.ID }}) {
	cf{{ firstCap $contentType.Sys.ID }} = &Cf{{ firstCap $contentType.Sys.ID }}{}
	{{ range $fieldIndex, $field := $contentType.Fields }}cf{{ firstCap $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }} = make(map[string]{{ mapFieldType $contentType.Sys.ID $field }})
	{{ end }}return
}

func (cc *contentfulClient) getAll{{ firstCap $contentType.Sys.ID }}() (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	return cc.getFiltered{{ firstCap $contentType.Sys.ID }}(nil)
}

func (cc *contentfulClient) getFiltered{{ firstCap $contentType.Sys.ID }}(query *contentful.Query) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc.CDA == nil {
		return nil, errors.New("getFiltered{{ firstCap $contentType.Sys.ID }}: No CDA client available")
	}
	col := cc.CDA.Entries.List(cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(10)
	col.GetAll()
	return colToCf{{ firstCap $contentType.Sys.ID }}(col)
}

func colToCf{{ firstCap $contentType.Sys.ID }}(col *contentful.Collection) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	for _, item := range col.Items {
		var vo Cf{{ firstCap $contentType.Sys.ID }}
		byteArray, _ := json.Marshal(item)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			break
		}
		vo.Col = col
		vos = append(vos, &vo)
	}
	return vos, err
}

func (ref ContentfulReferencedEntry) toCf{{ firstCap $contentType.Sys.ID }}() (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
		byteArray, _ := json.Marshal(ref.Entry)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			return nil, err
		}
		vo.Col = ref.Col
	return vo, nil
}

// {{ firstCap $contentType.Sys.ID }} Field getters
{{ range $fieldIndex, $field := $contentType.Fields }}
{{ if fieldIsBasic $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} {{ mapFieldType $contentType.Sys.ID $field }}, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if val, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; ok {
		{{ $field.ID }} = val
		return
	}
	err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: value for field and locale not found")
	return
}{{ end }}
{{ if fieldIsMultipleReference $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} []ContentfulReferencedEntry, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if localized{{ firstCap $field.ID }}, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; ok {
		for _, eachLocalized{{ firstCap $field.ID }} := range localized{{ firstCap $field.ID }} {
			includeEntryMap := vo.Col.ToIncludesEntryMap()
			var referencedEntry *contentful.Entry
			if ref, ok := includeEntryMap[eachLocalized{{ firstCap $field.ID }}.Sys.ID]; ok {
				referencedEntry = ref
			} else {
				err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: referenced entry not found in includes")
				return
			}

			{{ $field.ID }} = append({{ $field.ID }}, ContentfulReferencedEntry{
				Entry: referencedEntry,
				Col:   vo.Col,
			})
		}
		return
	}
	err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: value for field and locale not found")
	return
}{{ end }}
{{ if fieldIsReference $field }}func (vo *Cf{{ firstCap $contentType.Sys.ID }}) get{{ firstCap $field.ID }}(locale ...string) ({{ $field.ID }} ContentfulReferencedEntry, err error) {
	var loc string
	if len(locale) != 0 {
		loc = locale[0]
	} else {
		loc = defaultLocale
	}
	if localized{{ firstCap $field.ID }}, ok := vo.Fields.{{ firstCap $field.ID }}[loc]; ok {
		includeEntryMap := vo.Col.ToIncludesEntryMap()
		if referencedEntry, ok := includeEntryMap[localized{{ firstCap $field.ID }}.Sys.ID]; ok {
			{{ $field.ID }}.Entry = referencedEntry
			{{ $field.ID }}.Col = vo.Col
			return
		} 
		err = errors.New("CfFlyout.get{{ firstCap $field.ID }}: referenced entry not found in includes")
		return
	}

	err = errors.New("Cf{{ firstCap $contentType.Sys.ID }}.get{{ firstCap $field.ID }}: value for field and locale not found")
	return
}{{ end }}
{{ end }}{{ end }}
