// Package {{ .PackageName }} - DO NOT EDIT THIS FILE: Auto-generated code by https://github.com/foomo/contentful-erm
{{ $cfg := . }}{{ $locales := .Locales }}package {{ .PackageName }}

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"regexp"
	"strings"
	"time"
	"github.com/foomo/contentful"
)

type Locale string

{{ range $index , $locale := $locales }}const spaceLocale{{ onlyLetters $locale.Name }} Locale = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale Locale = spaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var localeFallback = map[Locale]Locale{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} spaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}spaceLocale{{ onlyLetters $localeSearch.Name }}{{ end }}{{ end }}, {{ else }}spaceLocale{{ onlyLetters $locale.Name }}: "", {{ end }}{{ end }}}

var (
	ErrLocaleUnsupported = errors.New("Locale not supported by this space")
	ErrNotSet            = errors.New("Field value not set")
	ErrNotSetNoFallback  = errors.New("Field value not set and no fallback locale available")
	ErrRefNotIncludes    = errors.New("Referenced entry not found in includes")
)

type ContentfulKeys struct {
	CDAKey  string
	CPAKey  string
	CMAKey  string
}
type ContentfulClient struct {
	SpaceID string
	CDA     *contentful.Contentful
	CPA     *contentful.Contentful
	CMA     *contentful.Contentful
	Debug   bool
	LogFn   func(
		contentType string,
		entryID string,
		method string,
		err error,
	)
}

func NewContentfulClient(spaceID string, ck *ContentfulKeys, logFn func(contentType string, entryID string, method string, err error), debug bool) (*ContentfulClient, error) {
	cc := &ContentfulClient{}
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	cc.SpaceID = spaceID
	if ck == nil {
		return nil, errors.New("NewContentfulClient: Please provide at least one API key")
	}
	if ck.CDAKey == "" && ck.CPAKey == "" && ck.CMAKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide at least one API Key")
	}
	if ck.CDAKey != "" {
		cc.CDA = contentful.NewCDA(ck.CDAKey)
		cc.CDA.Debug = debug
	}
	if ck.CPAKey != "" {
		cc.CPA = contentful.NewCPA(ck.CPAKey)
		cc.CPA.Debug = debug
	}
	if ck.CMAKey != "" {
		cc.CMA = contentful.NewCMA(ck.CMAKey)
		cc.CMA.Debug = debug
	}
	cc.LogFn = logFn
	return cc, nil
}

// Asset utils
func NewAssetFromURL(id string, uploadUrl string, imageFileType string, title string, locale ...Locale) *contentful.Asset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc Locale
	if len(locale) != 0 {
		loc = locale[0]
		if localeFallback[loc]!="" {
			return nil
		}
	} else {
		loc = defaultLocale
	}
	asset := &contentful.Asset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				string(loc): {
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				string(loc): title,
			},
		},
	}
	return asset
}

func ToAssetReference(asset *contentful.Asset) (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeAsset
	return
}

// RichText utils

func HtmlToRichText(htmlSrc string) *RichTextNode {
	htmlClean := strings.TrimSpace(htmlSrc)
	htmlClean = strings.ReplaceAll(htmlClean, `&nbsp;`, ` `)
	htmlClean = strings.ReplaceAll(htmlClean, "\t", "")
	htmlClean = regexp.MustCompile(`[\s]{2,}`).ReplaceAllString(htmlClean, " ")
	re := regexp.MustCompile(`>([^\n])`)
	htmlClean = re.ReplaceAllString(htmlClean, fmt.Sprintf(">\n"+`$1`))
	re = regexp.MustCompile(`(.{1})<`)
	htmlClean = re.ReplaceAllString(htmlClean, `$1`+fmt.Sprintf("\n<"))
	htmlLines := strings.Split(htmlClean, "\n")
	rtnd := &RichTextNode{
		NodeType: RichTextNodeDocument,
	}
	var isBasic bool
	rtnd.Content, _, isBasic = htmlLinesToRichTextNode(htmlLines, 0, "", nil, true)
	if isBasic {
		basicRich := &RichTextNode{
			NodeType: RichTextNodeDocument,
		}
		par := RichTextNode{
			NodeType: RichTextNodeParagraph,
		}
		par.Content = rtnd.Content
		basicRich.Content = append(basicRich.Content, par)
		return basicRich
	}
	return rtnd
}

func getMark(mark string) string {
	switch mark {
	case HtmlItalic, HtmlEm:
		return RichTextMarkItalic
	case HtmlBold, HtmlStrong:
		return RichTextMarkBold
	case HtmlUnderline:
		return RichTextMarkUnderline
	case HtmlCode:
		return RichTextMarkCode
	}
	return ""
}

func getAttribute(htmlLine string, attribute string) string {
	re := regexp.MustCompile(` href=["']([^"']+)["']`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func htmlLinesToRichTextNode(htmlLines []string, start int, pendingTag string, marks []string, isBasic bool) ([]interface{}, int, bool) {
	nodeSlice := make([]interface{}, 0)
	for i := start; i < len(htmlLines); i++ {
		htmlLine := htmlLines[i]
		if isClosingPending(htmlLine, pendingTag) {
			return nodeSlice, i, isBasic
		}
		currentNode := RichTextNode{}
		if isTag(htmlLine) {
			tt := tagType(htmlLine)
			switch tt {
			case HtmlParagraph, HtmlHeading1, HtmlHeading2, HtmlHeading3, HtmlHeading4, HtmlHeading5, HtmlHeading6, HtmlUnorderedList, HtmlOrderedList:
				isBasic = false
				currentNode.NodeType = mapTagRichTextNodeType(tt)
				var nextLine int
				currentNode.Content, nextLine, isBasic = htmlLinesToRichTextNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlBlockquote, HtmlListItem:
				isBasic = false
				currentNode.NodeType = mapTagRichTextNodeType(tt)
				currentNode.Content = make([]interface{}, 0)
				innerContent, nextLine, isBasic := htmlLinesToRichTextNode(htmlLines, i+1, tt, marks, isBasic)
				currentNode.Content = append(currentNode.Content, RichTextNode{
					NodeType: RichTextNodeParagraph,
					Content:  innerContent,
				})
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlCode:
				isBasic = false
				currentNode.NodeType = RichTextNodeParagraph
				var nextLine int
				currentNode.Content, nextLine, isBasic = htmlLinesToRichTextNode(htmlLines, i+1, HtmlCode, []string{HtmlCode}, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlAnchor:
				isBasic = false
				currentNode.NodeType = RichTextNodeHyperlink
				var nextLine int
				currentNode.Data = RichTextData{URI: getAttribute(htmlLine, HtmlAttributeHref)}
				currentNode.Content, nextLine, isBasic = htmlLinesToRichTextNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlHorizontalRule:
				isBasic = false
				currentNode.NodeType = RichTextNodeHR
				currentNode.Content = make([]interface{}, 0)
				nodeSlice = append(nodeSlice, currentNode)
			case HtmlItalic, HtmlEm, HtmlBold, HtmlStrong, HtmlUnderline:
				marks = append(marks, tt)
			case HtmlBreak:
				if len(nodeSlice) > 0 {
					myNode := nodeSlice[len(nodeSlice)-1]
					switch myNode.(type) {
					case RichTextNodeTextNode:
						myNodeTyped := myNode.(RichTextNodeTextNode)
						if myNodeTyped.NodeType == RichTextNodeText {
							myNodeTyped.Value += "\n"
							nodeSlice[len(nodeSlice)-1] = myNodeTyped
						}
					}
				}
			}
			continue //unsupported tags will be ignored but content is preserved
		}
		if isClosingTag(htmlLine) {
			continue //closing tags that are not pending equal to unknown
		}
		if htmlLine == " " {
			continue
		}
		currentNodeTextNode := RichTextNodeTextNode{}
		currentNodeTextNode.NodeType = RichTextNodeText
		currentNodeTextNode.Marks = []RichTextMark{}
		currentNodeTextNode.Value = htmlLine
		for _, mark := range marks {
			currentNodeTextNode.Marks = append(currentNodeTextNode.Marks, RichTextMark{
				Type: getMark(mark),
			})
		}
		marks = nil
		nodeSlice = append(nodeSlice, currentNodeTextNode)
	}
	return nodeSlice, -1, isBasic
}

func isClosingPending(htmlLine, tag string) bool {
	return regexp.MustCompile(`</` + strings.ToLower(tag) + `.+$`).MatchString(strings.ToLower(htmlLine))
}

func isClosingTag(htmlLine string) bool {
	return regexp.MustCompile(`</[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func isTag(htmlLine string) bool {
	return regexp.MustCompile(`<[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func mapTagRichTextNodeType(tag string) string {
	switch tag {
	case HtmlParagraph:
		return RichTextNodeParagraph
	case HtmlAnchor:
		return RichTextNodeHyperlink
	case HtmlHeading1:
		return RichTextNodeHeading1
	case HtmlHeading2:
		return RichTextNodeHeading2
	case HtmlHeading3:
		return RichTextNodeHeading3
	case HtmlHeading4:
		return RichTextNodeHeading4
	case HtmlHeading5:
		return RichTextNodeHeading5
	case HtmlHeading6:
		return RichTextNodeHeading6
	case HtmlBlockquote:
		return RichTextNodeBlockquote
	case HtmlUnorderedList:
		return RichTextNodeUnorderedList
	case HtmlOrderedList:
		return RichTextNodeOrderedList
	case HtmlListItem:
		return RichTextNodeListItem
	}
	return ""
}

func tagType(htmlLine string) string {
	re := regexp.MustCompile(`^<([a-zA-Z0-9]+)[\s]*>*`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func (ts htmlTags) open(w io.Writer) {

	for _, t := range ts {
		tagString := "<" + t.name
		if len(t.attrs) > 0 {
			for name, value := range t.attrs {
				tagString += " " + name + `="` + html.EscapeString(value) + `"`
			}
		}
		w.Write([]byte(tagString + ">"))
	}
}

func (ts htmlTags) close(w io.Writer) {

	for _, t := range ts {
		w.Write([]byte("</" + t.name + ">"))
	}
}

type LinkResolverFunc func(url string) (resolvedURL string, resolveError error)

func (n *RichTextGenericNode) renderHTML(w io.Writer, linkResolver LinkResolverFunc) (err error) {

	tags := htmlTags{}

	switch n.NodeType {
	case RichTextNodeParagraph:
		tags = []htmlTag{ {name: HtmlParagraph} }
	case RichTextNodeHeading1:
		tags = []htmlTag{ {name: HtmlHeading1} }
	case RichTextNodeHeading2:
		tags = []htmlTag{ {name: HtmlHeading2} }
	case RichTextNodeHeading3:
		tags = []htmlTag{ {name: HtmlHeading3} }
	case RichTextNodeHeading4:
		tags = []htmlTag{ {name: HtmlHeading4} }
	case RichTextNodeHeading5:
		tags = []htmlTag{ {name: HtmlHeading5} }
	case RichTextNodeHeading6:
		tags = []htmlTag{ {name: HtmlHeading6} }
	case RichTextNodeOrderedList:
		tags = []htmlTag{ {name: HtmlOrderedList} }
	case RichTextNodeUnorderedList:
		tags = []htmlTag{ {name: HtmlUnorderedList} }
	case RichTextNodeListItem:
		tags = []htmlTag{ {name: HtmlListItem} }
	case RichTextNodeHR:
		tags = []htmlTag{ {name: HtmlHorizontalRule} }
	case RichTextNodeBlockquote:
		tags = []htmlTag{ {name: HtmlBlockquote} }
	case RichTextNodeText:
		tags = []htmlTag{}
	case RichTextNodeHyperlink:
		uri, _ := n.Data["uri"]
		attrs := map[string]string{}
		switch uri.(type) {
		case string:
			uriString := uri.(string)
			if uriString != "" {
				resolvedURL, errResolveURL := linkResolver(uriString)
				if errResolveURL != nil {
					err = errResolveURL
					return
				}

				attrs["href"] = resolvedURL
			}

		}
		tags = []htmlTag{htmlTag{name: HtmlAnchor, attrs: attrs}}
	default:
	}
	for _, m := range n.Marks {
		markTag := ""
		switch m.Type {
		case RichTextMarkBold:
			markTag = HtmlBold
		case RichTextMarkItalic:
			markTag = HtmlItalic
		case RichTextMarkUnderline:
			markTag = HtmlUnderline
		case RichTextMarkCode:
			markTag = HtmlCode
		case RichTextNodeBlockquote:
			markTag = HtmlBlockquote
		}
		if markTag != "" {
			tags = append(tags, htmlTag{name: markTag})
		}
	}

	tags.open(w)
	w.Write([]byte(html.EscapeString(n.Value)))
	for _, subNode := range n.Content {
		errSubNode := subNode.renderHTML(w, linkResolver)
		if errSubNode != nil {
			err = errSubNode
			return
		}
	}
	tags.close(w)
	return
}

func RichTextToHtml(rt interface{}) string {
	w := bytes.NewBuffer([]byte{})
	node := &RichTextGenericNode{}
	byt, err := json.Marshal(rt)
	if err != nil {
		return ""
	}
	err = json.Unmarshal(byt, node)
	if err != nil {
		return ""
	}
	node.renderHTML(w, func(url string) (transformedURL string, err error) {
		return url, nil
	})
	out := string(w.Bytes())
	if out == "<p></p>" {
		return ""
	}
	return out
}

// Other utils

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}
